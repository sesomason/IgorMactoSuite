#pragma TextEncoding = "Shift_JIS"/////////////////////////////////////////////////////////////////////////////////////////////		mapping macro	ver. 1.3////		ver. 1.0		2010/08/20	Two_axis_plots2 panel and Graphical slicer//		ver. 1.1		2010/08/26	FS_mapping_windowを追加、Two_axis_plots2 panelを改良//		ver. 1.2		2010/09/01	3Dmatrix_kxkyを追加、Two_axis_plots2 panel等を改良//		ver. 1.3		2010/09/02	Mat3D_2derivを追加、Two_axis_plots2 panel等を改良//		ver. 1.3b	   2010/10/12  Twoaxis_3DMatrix_kxkyとTwoaxis_3DMatrix_kxky_perpのバグを修正//		ver. 1.3c	   2011/01/15  FS_kFkxky_perpのバグを修正、Two_axis_plots2 windowの3DMatrix選択方式を変更//// 		ver. 1.3.001   2011/06/17 Twoaxis_ImageTable()をSortingMacro起動方式に変更 //		ver. 1.3.001   2011/06/17 Twoaxis_3DMatrix_2Dto3D()に空白領域取り入れとimage_table以外のwaveの参照機能を追加//		ver. 1.3.002   2011/11/13  GS 3 window の色を最初からTerrainに変更//		ver. 1.3.003   2017/11/9  FS mapping window のボタンの位置の不具合を修正///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    Data_Analysis window   /////////////////////////////////////////////////////Window Data_Analysis2() : Panel	PauseUpdate; Silent 1		// building window...	String/G info="Graph info"	String/G xxbb="xwave"	String/G yybb="wave"	String/G ang="Angle"	NewPanel /W=(871,277,1127,714)	ModifyPanel cbRGB=(3,52428,1)	SetDrawLayer UserBack	SetDrawEnv fname= "Times",fsize= 15,fstyle= 1,textrgb= (0,13107,0)	DrawText 4,18,"Ushimacro ver 8.3"	SetDrawEnv linefgc= (65535,43690,0),fillfgc= (65535,43690,0)	DrawPoly 2,407,0.584415,0.828945,{206,258,228,277,207,277,206,258}	SetDrawEnv linefgc= (65535,43690,0),fillfgc= (65535,43690,0)	DrawPoly 238,1,0.8,0.75,{302,4,322,4,322,24,302,4}	DrawText 125,304,"% "	SetDrawEnv fname= "Times",fsize= 10	DrawText 125,14,"Copy right (2000) T. Sato "	SetDrawEnv fname= "Times",fsize= 14	DrawText 11,396,"Window offset"	SetDrawEnv linefgc= (65535,65532,16385),fillfgc= (65535,54607,32768),fillbgc= (65535,65533,32768)	DrawRRect 239,424,10,404	DrawRRect 297,441,295,441	SetDrawEnv linefgc= (49163,65535,32768),linebgc= (49163,65535,32768),fillfgc= (49163,65535,32768),fillbgc= (49163,65535,32768)	DrawRect 78,82,251,118	DrawRect 308,159,314,159	SetDrawEnv linefgc= (49163,65535,32768),linebgc= (49163,65535,32768),fillfgc= (49163,65535,32768),fillbgc= (49163,65535,32768)	DrawRect 233,20,116,79.9999999999999	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 101,399.999999999999,138,399.999999999999	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 146,399.999999999999,195,399.999999999999	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 8,351,95,351	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 10,375,138,375	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 149,375,222.999999999999,375	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 170,329,250,329	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 106,351,255,351	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 8,285,55,285	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 217,399.999999999999,245,399.999999999999	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 61,285,120,286	SetDrawEnv linefgc= (49163,65535,32768),linebgc= (49163,65535,32768),fillfgc= (49163,65535,32768),fillbgc= (49163,65535,32768)	DrawRect 255,191,1,242	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 50,216,90,216	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 139,216,179,216	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 50,240,90,240	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 97,239,187,239	SetVariable setvar0,pos={171,43},size={55,15},title=" ",value= K0	Button button0,pos={5,17},size={80,20},proc=ButtonProc,title="Make graph"	SetVariable setvar1,pos={171,60},size={55,15},title=" ",value= K1	SetVariable setvar2,pos={82,85},size={93,15},proc=SetVarProc,title="Ofst"	SetVariable setvar2,fSize=9,limits={-inf,inf,1000},value= K2	SetVariable setvar3,pos={81,101},size={94,15},proc=SetVarProc_2,title="base"	SetVariable setvar3,fSize=9,limits={-inf,inf,3000},value= K3	Button button2,pos={6,38},size={63,20},proc=ButtonProc_2,title="Append"	Button button4,pos={59,264},size={64,20},proc=ButtonProc_5,title="Plot N(k)"	Button button5,pos={6,80},size={63,21},proc=ButtonProc_8,title="Multiple"	SetVariable setvar4,pos={7,104},size={67,15},title="By"	SetVariable setvar4,limits={-inf,inf,0.01},value= K4	Button button6,pos={5,169},size={108,20},proc=ButtonProc_9,title="Waves to Matrix"	PopupMenu popup0,pos={121,168},size={104,17},proc=PopMenuProc,title="X wave"	PopupMenu popup0,mode=1,popvalue="xwave0",value= #"WaveList(\"xwave*\", \";\", \"\")"	Button button8,pos={6,308},size={62,20},proc=ButtonProc_11,title="Combine"	CheckBox check0,pos={70,311},size={59,14},proc=CheckProc,title="To waves"	CheckBox check0,value= 0	Button button1,pos={8,354},size={135,20},proc=ButtonProc_14,title="All waves to matrix"	Button button9,pos={7,330},size={88,20},proc=ButtonProc_15,title="Integ. norm."	Button button10,pos={67,147},size={81,20},proc=ButtonProc_16,title="Update"	SetVariable setvar6,pos={171,24},size={55,15},title=" ",value= K8	SetVariable setvar7,pos={18,246},size={100,15},proc=SetVarProc_3,title="MDC No."	SetVariable setvar7,value= K9	SetVariable setvar8,pos={125,243},size={108,21},proc=SetVarProc_4,title="EDC No."	SetVariable setvar8,fSize=14,value= K10	Button button11,pos={5,287},size={90,20},proc=ButtonProc_22,title="Symmetrize"	Button button12,pos={99,379},size={42,20},proc=ButtonProc_23,title="Const"	ValDisplay valdisp0,pos={97,289},size={26,13},limits={0,0,0},barmisc={0,1000}	ValDisplay valdisp0,value= #"k11"	Button button13,pos={125,264},size={65,20},proc=ButtonProc_24,title="Full MDC"	Button button14,pos={144,379},size={54,20},proc=ButtonProc_26,title="Special"	SetVariable setvar9,pos={15,408},size={222,15},fSize=9,value= msg	PopupMenu popup1,pos={96,331},size={128,17},proc=PopMenuProc_1,title="Wave color"	PopupMenu popup1,mode=2,popvalue="Inv. gray",value= #"\"Gray;Inv. gray;Rainbow;Inv. rainbow;black;red\""	SetVariable setvar10,pos={1,121},size={100,26},proc=SetVarProc_6,title="Graph"	SetVariable setvar10,fSize=16,value= K12	SetVariable setvar11,pos={103,125},size={87,15},title="info",value= Info	PopupMenu popup2,pos={154,145},size={84,17},proc=PopMenuProc_2,title="Color"	PopupMenu popup2,mode=2,popvalue="Black",value= #"\"Red;Black;Blue;Green;Yellow;Orange;Purple;Pink;Brown;Gray;Sky blue;Light green;Dark yellow\""	Button button15,pos={147,354},size={78,20},proc=ButtonProc_32,title="Band image"	Button button16,pos={168,308},size={83,20},proc=ButtonProc_33,title="Extrapolate"	SetVariable setvar12,pos={178,84},size={69,16},proc=SetVarProc_7,title="D"	SetVariable setvar12,font="Symbol",fSize=9,value= K13	SetVariable setvar13,pos={178,100},size={69,16},proc=SetVarProc_8,title="D"	SetVariable setvar13,font="Symbol",fSize=9,value= K14	Button button3,pos={139,286},size={76,20},proc=ButtonProc_48,title="Div. by FD"	Button button7,pos={191,264},size={60,20},proc=ButtonProc_49,title="Fit MDC"	SetVariable setvar5,pos={123,24},size={50,15},title=" ",value= xxbb	SetVariable setvar14,pos={123,43},size={50,15},title=" ",value= yybb	Button button17,pos={6,59},size={63,20},proc=ButtonProc_50,title="Remove"	CheckBox check1,pos={10,151},size={44,14},proc=CheckProc_3,title="Image"	CheckBox check1,value= 1	Button button18,pos={232,356},size={19,20},proc=ButtonProc_51,title="R"	Button button19,pos={7,264},size={50,20},proc=ButtonProc_64,title="Fit EDC"	Button button21,pos={232,330},size={17,20},proc=ButtonProc_69,title="M"	Button button22,pos={235,21},size={20,20},proc=ButtonProc_78,title="Kill"	Button button23,pos={216,379},size={31,20},proc=ButtonProc_79,title="Hide"	SetVariable setvar15,pos={189,124},size={67,15},value= ang	Button button24,pos={216,286},size={39,20},proc=ButtonProc_80,title="Comp"	Button button07,pos={8,195},size={35,20},proc=ButtonProc_showdata_EDC1,title="EDC"	Button button08,pos={50,195},size={40,20},proc=ButtonProc_showdata_EDC2,title="EDC2"	Button button09,pos={8,219},size={35,20},proc=ButtonProc_showdata_Mat1,title="Mat"	Button button20,pos={97,195},size={35,20},proc=ButtonProc_showdata_MDC1,title="MDC"	Button button25,pos={139,195},size={40,20},proc=ButtonProc_showdata_MDC2,title="MDC2"	Button button28,pos={50,219},size={40,20},proc=ButtonProc_showdata_Mat2,title="Mat2"	Button button29,pos={237,243},size={14,20},proc=ButtonProc_99,title="D"	Button button30,pos={97,218},size={90,20},proc=ButtonProc_showdata_sym,title="Symmetrize2"	Button button31,pos={194,218},size={40,20},proc=ButtonProc_show_mat,title="Show"EndMacro//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// showdata window //////////Window showdata() : Panel	PauseUpdate; Silent 1		// building window...	NewPanel /W=(665,286,860,350)	ModifyPanel cbRGB=(49151,60031,65535)	SetDrawLayer UserBack	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 52,27,92,27	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 52,52,92,52	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 99,52,139,52	SetDrawEnv linethick= 2,linefgc= (65535,16385,16385),linebgc= (65535,16385,16385)	DrawLine 146,27,186,27	Button button07,pos={5,5},size={40,20},proc=ButtonProc_showdata_EDC1,title="EDC"	Button button08,pos={52,5},size={40,20},proc=ButtonProc_showdata_EDC2,title="EDC2"	Button button09,pos={5,30},size={40,20},proc=ButtonProc_showdata_Mat1,title="Mat"	Button button20,pos={99,5},size={40,20},proc=ButtonProc_showdata_MDC1,title="MDC"	Button button25,pos={146,5},size={40,20},proc=ButtonProc_showdata_MDC2,title="MDC2"	Button button28,pos={52,30},size={40,20},proc=ButtonProc_showdata_Mat2,title="Mat2"	Button button30,pos={99,30},size={40,20},proc=ButtonProc_showdata_Sym,title="Sym"	Button button31,pos={146,30},size={40,20},proc=ButtonProc_show_mat,title="Show"EndMacroFunction ButtonProc_showdata_EDC1(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_EDC1()"EndFunction ButtonProc_showdata_EDC2(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_EDC2()"EndFunction ButtonProc_showdata_MDC1(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_MDC1()"EndFunction ButtonProc_showdata_MDC2(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_MDC2()"EndFunction ButtonProc_showdata_Mat1(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_Mat1()"EndFunction ButtonProc_showdata_Mat2(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_Mat2()"EndFunction ButtonProc_showdata_sym(ctrlName) : ButtonControl	String ctrlName	Execute"showdata_sym()"EndFunction ButtonProc_show_mat(ctrlName) : ButtonControl	String ctrlName		Execute "showmat()"Endmacro showdata_EDC1(Num_combine,wavehead,xwavehead)	//Info_waveを参照して2DMatrixのEDCを表示variable Num_combine=1Prompt Num_combine "Number of waves to be added"String matname=Info_Wave[K12]string wavenamestring xwavenamestring wavehead="tempw"Prompt wavehead "Name of new wave head"string xwavehead="tempwx"Prompt xwavehead "Name of new xwave head"variable xdim, ydimvariable xstart,xdeltavariable i=0, j=0variable Num_wavexdim=Dimsize($matname,0)ydim=Dimsize($matname,1)xstart=Dimoffset($matname,0)xdelta=Dimdelta($matname,0)Num_wave=floor(ydim/Num_combine)xwavename=xwaveheadMake/N=(xdim)/D/O $xwavenameSetScale/P x xstart,xdelta,"", $xwavename$xwavename=xpauseupdate; silent 1displayDo	wavename=wavehead+num2str(i)	Make/N=(xdim)/D/O $wavename	$wavename=0		showdata_EDC_func($wavename,$matname,Num_combine,i)		append $wavename vs $xwavename	i+=1while(i<Num_wave)endmacrofunction showdata_EDC_func(wavename,matname,Num_combine,i)wave wavename,matnamevariable Num_combine,ivariable j=0Do		wavename[]+=matname[p][i*Num_combine+j]		j+=1while(j<Num_combine)endmacro showdata_EDC2(Num_combine,wavehead,xwavehead)	//指定した2DMatrixのEDCを表示variable Num_combine=1Prompt Num_combine "Number of waves to be added"String ImageNames=ImageNameList("",";")	//top graph中のimageの名前を読み込むString matname=StringFromList(0,ImageNames,";")	//読み込んだListからstring wavenamestring xwavenamestring wavehead="tempw"Prompt wavehead "Name of new wave head"string xwavehead="tempwx"Prompt xwavehead "Name of new xwave head"variable xdim, ydimvariable xstart,xdeltavariable i=0, j=0variable Num_wavexdim=Dimsize($matname,0)ydim=Dimsize($matname,1)xstart=Dimoffset($matname,0)xdelta=Dimdelta($matname,0)Num_wave=floor(ydim/Num_combine)xwavename=xwaveheadMake/N=(xdim)/D/O $xwavenameSetScale/P x xstart,xdelta,"", $xwavename$xwavename=xpauseupdate; silent 1displayDo	wavename=wavehead+num2str(i)	Make/N=(xdim)/D/O $wavename	$wavename=0		showdata_EDC_func($wavename,$matname,Num_combine,i)		append $wavename vs $xwavename	i+=1while(i<Num_wave)endmacromacro showdata_MDC1(Num_combine,wavehead,xwavehead)	//Info_waveを参照or名前を入力して2DMatrixのMDCを表示variable Num_combine=1Prompt Num_combine "Number of waves to be added"String matname=Info_Wave[K12]string wavenamestring xwavenamestring wavehead="tempw"Prompt wavehead "Name of new wave head"string xwavehead="tempwx"Prompt xwavehead "Name of new xwave head"variable xdim, ydimvariable ystart,ydeltavariable i=0, j=0variable Num_wavexdim=Dimsize($matname,0)ydim=Dimsize($matname,1)ystart=Dimoffset($matname,1)ydelta=Dimdelta($matname,1)Num_wave=floor(xdim/Num_combine)xwavename=xwaveheadMake/N=(ydim)/D/O $xwavenameSetScale/P x ystart,ydelta,"", $xwavename$xwavename=xpauseupdate; silent 1displayDo	wavename=wavehead+num2str(i)	Make/N=(ydim)/D/O $wavename	$wavename=0		showdata_MDC_func($wavename,$matname,Num_combine,i)		append $wavename vs $xwavename	i+=1while(i<Num_wave)endmacrofunction showdata_MDC_func(wavename,matname,Num_combine,i)wave wavename,matnamevariable Num_combine,ivariable j=0Do		wavename[]+=matname[i*Num_combine+j][p]		j+=1while(j<Num_combine)endmacro showdata_MDC2(Num_combine,wavehead,xwavehead)	//activeになっているgraphの2DMatrixのMDCを表示variable Num_combine=1Prompt Num_combine "Number of waves to be added"String ImageNames=ImageNameList("",";")	//top graph中のimageの名前を読み込むString matname=StringFromList(0,ImageNames,";")	//読み込んだListからstring wavenamestring xwavenamestring wavehead="tempw"Prompt wavehead "Name of new wave head"string xwavehead="tempwx"Prompt xwavehead "Name of new xwave head"variable xdim, ydimvariable ystart,ydeltavariable i=0, j=0variable Num_wavexdim=Dimsize($matname,0)ydim=Dimsize($matname,1)ystart=Dimoffset($matname,1)ydelta=Dimdelta($matname,1)Num_wave=floor(xdim/Num_combine)xwavename=xwaveheadMake/N=(ydim)/D/O $xwavenameSetScale/P x ystart,ydelta,"", $xwavename$xwavename=xpauseupdate; silent 1displayDo	wavename=wavehead+num2str(i)	Make/N=(ydim)/D/O $wavename	$wavename=0		showdata_MDC_func($wavename,$matname,Num_combine,i)		append $wavename vs $xwavename	i+=1while(i<Num_wave)endmacromacro showdata_Mat1()	//Info_waveを参照or名前を入力して2Dmatrixを表示String matname=Info_Wave[K12]pauseupdate; silent 1Display;AppendImage $matnameModifyImage $matname ctab= {*,*,YellowHot,0}endmacroMacro showdata_Mat2(Mat2DName)	//activeになっているgraphにtraceされているwaveから2Dmatrixを作成して表示String Mat2Dname="Matrixname"Prompt Mat2DName "Name of new matrix"String tracelist=TraceNameList("",";",1)variable Num_wave=ItemsInList(tracelist,";")	//graphにtraceされているwaveの数を読み込みString ywaveString xwave=wavename("",0,2)	//top graphに表示してあるxwaveの名前を読み込みMake/N=(Dimsize($xwave,0),Num_wave)/D/O $Mat2DNameSetScale/P x Dimoffset($xwave,0),Dimdelta($xwave,0),"", $Mat2DNamepauseupdate; silent 1variable i=0Do	ywave=wavename("",i,1)	//topgraphに表示してあるywaveの名前を読み込み	$Mat2DName[][i]=$ywave[p]	i+=1while(i<Num_wave)Display;AppendImage $Mat2DNameModifyImage $Mat2DName ctab= {*,*,YellowHot,0}endmacroMacro showdata_sym(Num_interp,ShiftEF,sbase,sxbase)	//top graph中のwaveを対称化Variable Num_interp=2000Prompt Num_interp "Input data number of interpolated waves"String ywave,xwaveString iwavename="iwave",ixwavename="ixwave"String sbase="tempsw"Prompt sbase "Name of new swave head"String sxbase="tempswx"Prompt sxbase "Name of new sxwave head"String swavenameString sxwavenameString TraceList=TraceNameList("",";",1)Variable Num_wave=ItemsInList(TraceList,";")	//graphにtraceされているwaveの数を読み込みvariable totalswavevariable ShiftEF=0	//EF補正Prompt ShiftEF "Input Fermi energy"variable k	pauseUpdate; Silent 1	Variable i=0	ywave=wavename("",i,1)	//ywave名を読み込み	xwave=wavename("",i,2)	//xwave名を読み込み	swavename=sbase+num2istr(i)			//対称化wave名の定義	sxwavename=sxbase+num2istr(i)	Interpolate/T=3/N=(Num_interp)/F=1/S=0/Y=$iwavename/X=$ixwavename $ywave /X=$xwave		//元waveの補間	SetScale/I x ($ixwavename[0]-ShiftEF),($ixwavename[Dimsize($ixwavename,0)-1]-ShiftEF),"", $ixwavename		//補間waveのxscaleの調整	totalswave=(Dimsize($ixwavename,0)-x2pnt($ixwavename,0.0))*2+1	//swaveのpnt数を計算	ResumeUpdate	pauseUpdate; Silent 1	Make/N=(totalswave)/D/O $sxwavename		//対称化xwaveの生成	SetScale/I x -($ixwavename[Dimsize($ixwavename,0)-1]-ShiftEF),($ixwavename[Dimsize($ixwavename,0)-1]-ShiftEF),"", $sxwavename		//対称化waveのxscale調整	$sxwavename=x	Make/N=(totalswave)/D/O $swavename		//対称化waveの生成	k=0		showdata_sym_func($swavename,$iwavename,k)		//対称化のためのfunctionを読み込み実行i+=1if(i<Num_wave)	Do	ywave=wavename("",i,1)	//ywave名を読み込み	xwave=wavename("",i,2)	//xwave名を読み込み	swavename=sbase+num2istr(i)			//対称化wave名の定義	Interpolate/T=3/N=(Num_interp)/F=1/S=0/Y=$iwavename/X=$ixwavename $ywave /X=$xwave		//元waveの補間	ResumeUpdate	pauseUpdate; Silent 1	Make/N=(totalswave)/D/O $swavename		//対称化waveの生成	k=0		showdata_sym_func($swavename,$iwavename,k)		//対称化のためのfunctionを読み込み実行			i+=1	While (i<Num_wave)Endifi=0swavename=sbase+num2istr(i)sxwavename=sxbase+num2istr(i)display $swavename vs $sxwavenamei+=1if(i<Num_wave)	Do		swavename=sbase+num2istr(i)				AppendtoGraph $swavename vs $sxwavename		//対称化waveを連続して表示				i+=1	While (i<Num_wave)endifEndmacrofunction showdata_sym_func(sw,iw,k)wave swwave iwvariable kDo		sw[k]=iw[Dimsize(iw,0)-1-k]+iw[Dimsize(iw,0)-1-Dimsize(sw,0)+k]		//対称化waveの定義		k+=1		While (k<Dimsize(sw,0))End//////////////////////////////////////////////////// showmat window //////////Window showmat() : Graph	Variable/G showmat_norm=1	String/G showmat_sens="sensitivitiy"	variable/G showmat_energy=1	String/G info=Info_Wave[K12]	String/G ang=num2str(Angle[K12])	Make/N=3/D/O showmat_coef	showmat_coef[0]=0					//startpnt	showmat_coef[1]=300				//endpnt	showmat_coef[2]=16.824			//EF	string matname	matname=info_wave[K12]	duplicate /o $matname showmat_image		PauseUpdate; Silent 1		// building window...	Display /W=(650,377,884,695)	AppendImage showmat_image	ModifyImage showmat_image ctab= {*,*,YellowHot,0}	ModifyGraph cbRGB=(49151,60031,65535)	ModifyGraph mirror=2	ControlBar 76	SetVariable setvar10,pos={4,5},size={85,18},proc=SetVarProc_showmat_graphnum,title="Graph"	SetVariable setvar10,fSize=12,fStyle=1,value= K12	SetVariable setvar11,pos={90,6},size={75,15},value= Info	PopupMenu popup0,pos={6,29},size={82,17},proc=PopMenuProc_showmat_norm,fSize=9	PopupMenu popup0,mode=1,popvalue="Raw data",value= #"\"Raw data;Normalized;Div by sens\""	SetVariable setvar15,pos={169,6},size={50,15},value= ang	SetVariable setvar0,pos={106,30},size={68,15},proc=SetVarProc_showmat,title="csr from"	SetVariable setvar0,limits={-inf,inf,0},value= showmat_coef[0]	SetVariable setvar1,pos={179,30},size={40,15},proc=SetVarProc_showmat,title="to"	SetVariable setvar1,limits={-inf,inf,0},value= showmat_coef[1]	SetVariable setvar2,pos={5,54},size={78,15},proc=SetVarProc_showmat,title="sens"	SetVariable setvar2,limits={-inf,inf,0},value= showmat_sens	PopupMenu popup1,pos={91,52},size={49,17},proc=PopMenuProc_showmat_energy	PopupMenu popup1,mode=1,popvalue="K.E.",value= #"\"K.E.;B.E.\""	SetVariable setvar3,pos={146,54},size={56,15},proc=SetVarProc_showmat,title="EF"	SetVariable setvar3,limits={-inf,inf,0},value= showmat_coef[2]	Button button0,pos={208,51},size={15,20},proc=ButtonProc_showmat_duplicate,title="C"	Button button0,font="Osaka"	ModifyGraph swapXY=1EndMacroFunction SetVarProc_showmat_graphnum(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G showmat_norm		Execute "showmat_graphchange()"		If (showmat_norm==1)	Execute "showmat1()"	endif		if(showmat_norm==2)	Execute "showmat2()"	endif		If (showmat_norm==3)	Execute "showmat3()"	endifEndFunction PopMenuProc_showmat_norm(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G showmat_norm		switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		showmat_norm=popNum		If (showmat_norm==1)	Execute "showmat1()"	endif		if(showmat_norm==2)	Execute "showmat2()"	endif		If (showmat_norm==3)	Execute "showmat3()"	endif	EndFunction SetVarProc_showmat(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G showmat_norm			If (showmat_norm==1)	Execute "showmat1()"	endif		if(showmat_norm==2)	Execute "showmat2()"	endif		If (showmat_norm==3)	Execute "showmat3()"	endifEndFunction PopMenuProc_showmat_energy(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G showmat_energy	variable/G showmat_norm	switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		showmat_energy=popNum			If (showmat_norm==1)	Execute "showmat1()"	endif		if(showmat_norm==2)	Execute "showmat2()"	endif		If (showmat_norm==3)	Execute "showmat3()"	endif	Endmacro showmat_graphchange()info=Info_Wave[K12]ang=num2str(Angle[K12])endmacro showmat1()string matnamematname=info_wave[K12]PauseUpdate; Silent 1		// building window...duplicate /o $matname showmat_imageIf (showmat_energy==2)SetScale/P x (dimoffset(showmat_image,0)-showmat_coef[2]),dimdelta(showmat_image,0),"", showmat_imageendifendmacro showmat2()string matnamematname=info_wave[K12]variable ydim=Dimsize($matname,1)string tempsensitivity="temp_sens"PauseUpdate; Silent 1		// building window...duplicate /o $matname showmat_imageMake/N=(ydim)/D/O $tempsensitivity$tempsensitivity=0showmat_norm2($tempsensitivity, $matname, showmat_coef[0], showmat_coef[1], ydim)showmat_image[][]/=$tempsensitivity[q]wavestats/Q showmat_imageshowmat_image*=50000/v_maxIf (showmat_energy==2)SetScale/P x (dimoffset(showmat_image,0)-showmat_coef[2]),dimdelta(showmat_image,0),"", showmat_imageendifendfunction showmat_norm2(senswave, matrixname, startpnt, endpnt, ydim)wave senswavewave matrixnamevariable startpnt, endpnt, ydimvariable i=startpntDo		senswave[]+=matrixname[i][p]	i+=1	while(i<endpnt+1)endmacro showmat3()string matnamematname=info_wave[K12]PauseUpdate; Silent 1		// building window...duplicate /o $matname showmat_imageshowmat_image[][]/=$showmat_sens[q]If (showmat_energy==2)SetScale/P x (dimoffset(showmat_image,0)-showmat_coef[2]),dimdelta(showmat_image,0),"", showmat_imageendifendFunction ButtonProc_showmat_duplicate(ctrlName) : ButtonControlString ctrlName	Execute"showmat_duplicate()"Endmacro showmat_duplicate(matname)string matname="Matrixname"duplicate/o showmat_image $matnamePauseUpdate; Silent 1	display;appendimage $matnameModifyImage $matname ctab= {*,*,YellowHot,0}end//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   Two_axis_plots2 window   ///////////////////////////////////////////////////////Window Two_axis_Plots2() : Panel	PauseUpdate; Silent 1		// building window...	NewPanel /W=(872,46,980,236) as "Two_axis_Plots2"	ModifyPanel cbRGB=(65535,49151,55704)	SetDrawLayer UserBack	SetDrawEnv fillfgc= (13107,13107,13107),fillbgc= (8738,8738,8738)	DrawPoly 92,0,0.764706,0.722222,{130,5,147,5,147,23,130,5}	SetDrawEnv fillfgc= (8738,8738,8738),fillbgc= (8738,8738,8738)	DrawPoly 2,171,0.736842,0.736842,{5,181,5,200,24,200,5,181}	Button button0,pos={8.00,4.00},size={92.00,20.00},proc=ButtonProc_DataNameLoad,title="update_Info"	Button button1,pos={8.00,26.00},size={92.00,20.00},proc=ButtonProc_ImageTable,title="Image table"	Button button2,pos={8.00,48.00},size={92.00,20.00},proc=ButtonProc_3DMatrix_2Dto3D,title="3Dmatrix"	Button button3,pos={8.00,70.00},size={92.00,20.00},proc=ButtonProc_3DMatrix_showGS,title="Show GS"	Button button4,pos={8.00,92.00},size={92.00,20.00},proc=ButtonProc_3DMatrix_FS_mapping,title="FS mapping"	Button button5,pos={8.00,114.00},size={92.00,20.00},proc=ButtonProc_3DMatrix_2deriv,title="2nd derivative"	Button button6,pos={8.00,136.00},size={92.00,20.00},proc=ButtonProc_3DMatrix_angletok,title="3D(angle->k)"	PopupMenu GS_mat3DName,pos={7.00,159.00},size={117.00,23.00},proc=PopMenuProc_GS_mat3Dname	PopupMenu GS_mat3DName,mode=1,popvalue="Matrix3DName",value= #"WaveList(\"Matrix3D*\", \";\", \"\")"EndMacroFunction ButtonProc_DataNameLoad(ctrlName) : ButtonControl	String ctrlName	Execute"Auto_DataNameLoad2()"EndFunction ButtonProc_ImageTable(ctrlName) : ButtonControl	String ctrlName		Dowindow SortFor3Dmap	if (V_flag==0)		Execute "SetUpSort3D()" 	endif	Dowindow/F SortFor3DmapEndFunction ButtonProc_3DMatrix_2Dto3D(ctrlName) : ButtonControl	String ctrlName	Execute"Twoaxis_3DMatrix_2Dto3D()"EndFunction ButtonProc_3DMatrix_showGS(ctrlname) : ButtonControlstring ctrlNameExecute "GS_Energy()"Execute "GS_theta()"Execute "GS_phi()"EndFunction ButtonProc_3DMatrix_FS_mapping(ctrlname) : ButtonControlstring ctrlNameExecute "FS_mapping_window()"EndMacro Auto_DataNameLoad2(loadn,startn,Mathead,StartMat)Variable loadn=5,startn=0,StartMat=0,String MatHead="F"Prompt loadn "Number of matrix data to load->"Prompt startn "start table number->"Prompt MatHead, "Head string of the matrix->"Prompt StartMat, "Start number of the matrix->"String MatName=MatHead+num2istr(StartMat)variable n=0String Matri,WNRedimension/N=(loadn+startn) Info_Wave		//テーブルポイント数の再定義Redimension/N=(loadn+startn) memoRedimension/N=(loadn+startn) AngleRedimension/N=(loadn+startn) X_baseRedimension/N=(loadn+startn) Y_baseRedimension/N=(loadn+startn) X_start_WaveRedimension/N=(loadn+startn) Start_WaveRedimension/N=(loadn+startn) Last_WaveRedimension/N=(loadn+startn) Offset_WaveRedimension/N=(loadn+startn) Bias_WaveRedimension/N=(loadn+startn) AngleX_base="xwave"Y_base="wave"Pauseupdate; silent 1Do	If (StartMat<1000)									//マトリックス名の自動定義, 0???, 00??, 000?の場合	MatName=MatHead+"0"+num2istr(StartMat)	Endif		If (StartMat<100)	MatName=MatHead+"00"+num2istr(StartMat)	Endif		If (StartMat<10)	MatName=MatHead+"000"+num2istr(StartMat)	Endif			Info_Wave[n+startn]=MatName			//テーブルに情報を更新		Resumeupdate;	Pauseupdate; silent 1	n+=1StartMat+=1While (n<loadn)EndMacroMacro Twoaxis_ImageTable()//String bi="image_table"		//Make/N=1/D/O $bi//Edit $bi	End Macromacro Twoaxis_3DMatrix_2Dto3D(Mat3D, IntegYesNo, Startpnt, Endpnt, SensYesNo, SensName, Phiangle, StartPhi, EndPhi, imagename)		//2Dmatrixを足し合わせて3DMatrixを作製&ノーマライズ	String Mat3D="Matrix3Dname"	variable IntegYesNo=2	Prompt IntegYesNo "Normalization?", popup, "No;Yes(Theta);Yes(Theta&Phi)"	//No=1, Theta=2, Theta&Phi=3	variable Startpnt=0	Prompt Startpnt "Start point"	variable Endpnt=300	Prompt Endpnt "End point"	variable SensYesNo=1	Prompt SensYesNo "Division by sensitivity?", popup, "No;Yes"	//No=1, Yes=2	String SensName="Sensitivity"	variable Phiangle=1	Prompt Phiangle "Acceptance angle?", popup, "Read from data;Input by yourself"	//Read from data=1, Input by yourself=2	variable Startphi=-7	Prompt StartPhi "Start angle"	variable Endphi=7	Prompt EndPhi "End angle"	String ImageList, imagename	Prompt imagename "Image table Name", popup, wavelist("image_table*", ";","DIMS:1")		String aname, infoname			/////////  image_table*** と同じsuffixを持つ angleとinfowaveを指定	String suffix,fc,ss1	variable sl,conds	sl = strlen(imagename)	ss1 = imagename[11,sl]	fc = ss1[0]	conds = cmpstr(fc,"_")	if (conds==0)		ss1 = imagename[12,sl]	endif	suffix = ss1	aname = "angle_"+suffix	infoname = "info_"+suffix			String matname=Info_Wave[$imagename[0]]	variable xdim, ydim	variable div	variable start_angle=$aname[0]	variable delta_angle=$aname[1]-$aname[0]		xdim=Dimsize($matname,0)	ydim=Dimsize($matname,1)	Make/N=(xdim,ydim,Dimsize($imagename,0))/D/O $Mat3D	////////  3Dmat 本体の作成	Make/N=(xdim,ydim)/D/O  DummyMat	DummyMat =nan			///////////////////////////////////////////// Dummymat作成		SetScale/P x Dimoffset($matname,0),Dimdelta($matname,0),"", $Mat3D	SetScale/P z start_angle,delta_angle,"", $Mat3D	if (Phiangle==1)	SetScale/P y Dimoffset($matname,1),Dimdelta($matname,1),"", $Mat3D	endif	If (Phiangle==2)	SetScale/I y Startphi,Endphi,"", $Mat3D	endif	variable i=0	variable j=0	variable cond1		String tempsensitivity="temp_sens"	Make/N=(ydim)/D/O $tempsensitivity	duplicate/o $matname temp_matPauseUpdate;Silent 1	Do		i=$imagename[j]		matname=$infoname[j]				cond1 = waveexists($matname) 		if (IntegYesNo==1)					if (cond1==0 ||  numtype(i)==2)				$mat3D[][][j]=nan			else				$mat3D[][][j]=$matname[p][q]			endif					Endif				if (IntegYesNo==2)					if (cond1==0 ||  numtype(i)==2)				$mat3D[][][j]=nan			else				div=Twoaxis_3Dmat_sum($matname, startpnt, endpnt, ydim)				$mat3D[][][j]=$matname[p][q]/div			endif		Endif				if (IntegYesNo==3)						if (cond1==0 ||  numtype(i)==2)				$mat3D[][][j]=nan			else				Twoaxis_3Dmat_sum2($tempsensitivity, $matname, startpnt, endpnt, ydim)				temp_mat[][]=$matname[p][q]				temp_mat/=$tempsensitivity[q]				$mat3D[][][j]=temp_mat[p][q]			endif				Endif		j+=1	while (j<Dimsize($imagename,0))Wavestats/Q $mat3D$mat3D*=50000/V_maxif(SensYesNo==2)	$mat3D[][][]/=$SensName[q]Endifendmacrofunction Twoaxis_3Dmat_sum(matrixname, startpnt, endpnt, ydim)wave matrixnamevariable startpnt, endpnt, ydimvariable i=startpntvariable j=0variable div=0Do	Do			div+=matrixname[i][j]		i+=1		while(i<endpnt+1)	j+=1	i=startpntWhile(j<ydim)return(div)endfunction Twoaxis_3Dmat_sum2(senswave, matrixname, startpnt, endpnt, ydim)wave senswavewave matrixnamevariable startpnt, endpnt, ydimvariable i=startpntsenswave=0Do	senswave[]+=matrixname[i][p]	i+=1	while(i<endpnt+1)endFunction ButtonProc_3DMatrix_angletok(ctrlname) : ButtonControlstring ctrlNamevariable/G FS_ARPESmodeIf(FS_ARPESmode==1)Execute "Twoaxis_3DMatrix_kxky()"endifIf(FS_ARPESmode==2)Execute "Twoaxis_3DMatrix_kxky_perp()"endifEndFunction PopMenuProc_GS_mat3Dname(ctrlname, popnum, popstr) : PopupMenuControl	String ctrlName	Variable popNum	String popstr		String/G GS_mat3DName	GS_mat3DName=popstr	EndMacro Twoaxis_3DMatrix_kxky(MatName,NewName)		//Matrix3DNameをkxky変換String MatName="Matrix3DName"			// X : energy  Y : 取り込み角  Z : theta   Prompt MatName "Original 3Dmatrix name"String NewName="Matrix3Dnamekxky"Prompt NewName "New 3Dmatrix name"Pauseupdate; silent 1Variable  rad=pi/180variable EF=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable thetaoffset=FSmap_coef[5]variable tilt=FSmap_coef[6]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]				//theta方向のmeshVariable vmesh=FSmap_coef[12]				//取り込み角方向のmeshFSmap_coef[13]=hmesh/Dimsize($matname,2)+0.5		//+0.5 は経験的にInt_kxkyに空白が現れない、かつ適度に小さい値FSmap_coef[14]=vmesh/Dimsize($matname,1)Variable  Interpfactorh=FSmap_coef[13]		//元データをinterpolateするときの指数	Interpolate後のデータ点は:  (元データのmesh数-1)*Interpfactor+1Variable  Interpfactorv=FSmap_coef[14]variable dimenergy=Dimsize($matname,0)variable ydim=Dimsize($matname,1)variable zdim=Dimsize($matname,2)Make/O/N=(zdim, ydim, dimenergy) Mat3Dtemp		//theta方向&取り込み角方向にdataをinterpolationするため、XとZを入れ替えた3Dmatrixを作るMat3Dtemp[][][]=$matname[r][q][p]			// X : theta Y : 取り込み角  Z : energyImageinterpolate/f={(Interpfactorh),(Interpfactorv)} bilinear Mat3Dtemp	//データをinterpolate, M_interpolatedImageという名前のmatrixが作成されるSetScale/I x (Dimoffset($Matname,2)),(Dimoffset($Matname,2)+(Dimsize($Matname,2)-1)*Dimdelta($Matname,2)),"", M_interpolatedimage	//Interpolateした後のmatrixのscale設定SetScale/I y (-angaccept/2),(angaccept/2),"", M_interpolatedimageSetScale/I z (Dimoffset($Matname,0)),(Dimoffset($Matname,0)+(Dimsize($Matname,0)-1)*Dimdelta($Matname,0)),"", M_interpolatedimageduplicate/o M_interpolatedimage kx0duplicate/o M_interpolatedimage ky0duplicate/o M_interpolatedimage kxduplicate/o M_interpolatedimage kyky[][]=cos((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(y*rad)+cos((x+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(y*rad)))+sin((azimuth+azimuthoffset)*rad)*(-sqrt(z/3.81283)*sin((x+thetaoffset)*rad)*cos(y*rad))	//kyの計算kx[][]=sin((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(y*rad)+cos((x+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(y*rad)))-cos((azimuth+azimuthoffset)*rad)*(-sqrt(z/3.81283)*sin((x+thetaoffset)*rad)*cos(y*rad))	//kxの計算If(FS_kunit==2)ky/=pi/b0kx/=pi/a0endifMake/N=(hmesh, vmesh,dimenergy)/D/O Mat3Dkxky_temp		//Mat3Dkxky_tempの生成Mat3dkxky_temp=NanSetScale/P z (Dimoffset($Matname,0)),(Dimdelta($matname,0)),"", Mat3Dkxky_temp	//Mat3Dkxky_tempのscale設定WaveStats/Q kxSetScale/I x, V_min, V_max, "",Mat3Dkxky_tempWaveStats/Q kySetScale/I y, V_min, V_max, "",Mat3Dkxky_tempkx0[][][]=round( (kx[p][q][r]-Dimoffset(Mat3Dkxky_temp,0))/Dimdelta(Mat3Dkxky_temp,0) )ky0[][][]=round( (ky[p][q][r]-Dimoffset(Mat3Dkxky_temp,1))/Dimdelta(Mat3Dkxky_temp,1) )Variable  xdiminterp=Dimsize(M_interpolatedimage,0)variable ydiminterp=Dimsize(M_interpolatedimage,1)Variable i=0Variable j=0variable k=0Twoaxis_3DMatrix_kxky_input(xdiminterp, ydiminterp, dimenergy, i, j, k, kx0, ky0, M_interpolatedimage,Mat3Dkxky_temp)Make/N=(dimenergy, vmesh, hmesh)/D/O $newname	//Mat3Dkxkyの作成		Mat3Dkxky_tempのXとZを入れ替える$newname[][][]=Mat3Dkxky_temp[r][q][p]			//X : energy  Y : 取り込み  Z : thetaSetScale/P x (Dimoffset($Matname,0)),(Dimdelta($matname,0)),"",$newname	//Mat3Dkxky_tempのscale設定Setscale/P y (Dimoffset(Mat3Dkxky_temp,1)),(Dimdelta(Mat3Dkxky_temp,1)),"",$newnameSetscale/P z (Dimoffset(Mat3Dkxky_temp,0)),(Dimdelta(Mat3Dkxky_temp,0)),"",$newnamekillwaves Mat3Dtemp, M_interpolatedimage, Mat3Dkxky_temp, kx, ky, kx0, ky0//imagestats $NewName		//i強度を0-1に規格化//$NewName-=V_min//Imagestats $NewName//$NewName/=V_maxendfunction Twoaxis_3DMatrix_kxky_input(xdim, ydim, zdim, i, j, k, kx0, ky0, Interpmat, mat)	wave kx0, ky0, Interpmat, mat	variable xdim, ydim, zdim, i, j, kDo		Do		Do		mat[kx0[i][j][k]][ky0[i][j][k]][k]=interpmat[i][j][k]		i+=1		while (i<xdim)	j+=1	i=0	While(j<ydim)i=0j=0k+=1while(k<zdim)endMacro Twoaxis_3DMatrix_kxky_perp(MatName,NewName)		//Matrix3DNameをkxky変換		analyzer slitとmanipulatorが垂直なとき用String MatName="Matrix3DName"			// X : energy  Y : 取り込み角  Z : tilt   Prompt MatName "Original 3Dmatrix name"String NewName="Matrix3Dnamekxky"Prompt NewName "New 3Dmatrix name"Pauseupdate; silent 1Variable  rad=pi/180variable EF=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable theta=FSmap_coef[4]variable thetaoffset=FSmap_coef[5]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]				//theta方向のmeshVariable vmesh=FSmap_coef[12]				//取り込み角方向のmeshFSmap_coef[13]=hmesh/Dimsize($matname,2)+0.5		//+0.5 は経験的にInt_kxkyに空白が現れない、かつ適度に小さい値FSmap_coef[14]=vmesh/Dimsize($matname,1)+0.2Variable  Interpfactorh=FSmap_coef[13]		//元データをinterpolateするときの指数	Interpolate後のデータ点は:  (元データのmesh数-1)*Interpfactor+1Variable  Interpfactorv=FSmap_coef[14]variable dimenergy=Dimsize($matname,0)variable ydim=Dimsize($matname,1)variable zdim=Dimsize($matname,2)Make/O/N=(zdim, ydim, dimenergy) Mat3Dtemp		//theta方向&取り込み角方向にdataをinterpolationするため、XとZを入れ替えた3Dmatrixを作るMat3Dtemp[][][]=$matname[r][q][p]			// X : tilt Y : 取り込み角  Z : energyImageinterpolate/f={(Interpfactorh),(Interpfactorv)} bilinear Mat3Dtemp	//データをinterpolate, M_interpolatedImageという名前のmatrixが作成されるSetScale/I x (Dimoffset($Matname,2)),(Dimoffset($Matname,2)+(Dimsize($Matname,2)-1)*Dimdelta($Matname,2)),"", M_interpolatedimage	//Interpolateした後のmatrixのscale設定SetScale/I y (angaccept/2),(-angaccept/2),"", M_interpolatedimageSetScale/I z (Dimoffset($Matname,0)),(Dimoffset($Matname,0)+(Dimsize($Matname,0)-1)*Dimdelta($Matname,0)),"", M_interpolatedimageduplicate/o M_interpolatedimage kx0duplicate/o M_interpolatedimage ky0duplicate/o M_interpolatedimage kxduplicate/o M_interpolatedimage kyky[][]=cos((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(sin((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*sin(y*rad)+cos((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*cos(y*rad)))+sin((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(cos((theta+thetaoffset)*rad)*sin(y*rad)-sin((theta+thetaoffset)*rad)*cos(y*rad)))	//kxの計算kx[][]=sin((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(sin((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*sin(y*rad)+cos((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*cos(y*rad)))-cos((azimuth+azimuthoffset)*rad)*(sqrt(z/3.81283)*(cos((theta+thetaoffset)*rad)*sin(y*rad)-sin((theta+thetaoffset)*rad)*cos(y*rad)))	//kyの計算If(FS_kunit==2)ky/=pi/b0kx/=pi/a0endifMake/N=(hmesh, vmesh,dimenergy)/D/O Mat3Dkxky_temp		//Mat3Dkxky_tempの生成Mat3dkxky_temp=NanSetScale/P z (Dimoffset($Matname,0)),(Dimdelta($matname,0)),"", Mat3Dkxky_temp	//Mat3Dkxky_tempのscale設定WaveStats/Q kxSetScale/I x, V_min, V_max, "",Mat3Dkxky_tempWaveStats/Q kySetScale/I y, V_min, V_max, "",Mat3Dkxky_tempkx0[][][]=round( (kx[p][q][r]-Dimoffset(Mat3Dkxky_temp,0))/Dimdelta(Mat3Dkxky_temp,0) )ky0[][][]=round( (ky[p][q][r]-Dimoffset(Mat3Dkxky_temp,1))/Dimdelta(Mat3Dkxky_temp,1) )Variable  xdiminterp=Dimsize(M_interpolatedimage,0)variable ydiminterp=Dimsize(M_interpolatedimage,1)Variable i=0Variable j=0variable k=0Twoaxis_3DMatrix_kxky_input(xdiminterp, ydiminterp, dimenergy, i, j, k, kx0, ky0, M_interpolatedimage,Mat3Dkxky_temp)Make/N=(dimenergy, vmesh, hmesh)/D/O $newname	//Mat3Dkxkyの作成		Mat3Dkxky_tempのXとZを入れ替える$newname[][][]=Mat3Dkxky_temp[r][q][p]			//X : energy  Y : 取り込み  Z : tiltSetScale/P x (Dimoffset($Matname,0)),(Dimdelta($matname,0)),"",$newname	//Mat3Dkxky_tempのscale設定Setscale/P y (Dimoffset(Mat3Dkxky_temp,1)),(Dimdelta(Mat3Dkxky_temp,1)),"",$newnameSetscale/P z (Dimoffset(Mat3Dkxky_temp,0)),(Dimdelta(Mat3Dkxky_temp,0)),"",$newnamekillwaves Mat3Dtemp, M_interpolatedimage, Mat3Dkxky_temp, kx, ky, kx0, ky0//imagestats $NewName		//i強度を0-1に規格化//$NewName-=V_min//Imagestats $NewName//$NewName/=V_maxendmacro Twoaxis_Mat3D_2deriv(mode,newname,pointnum2,repetitionnum2,pointnum4,repetitionnum4,pointnumb,repetitionnumb,mat3d)		//3Dmatrixを二階微分variable mode=0		//2階微分を行う方向		0 : EDC	1 : MDC(parallel to slit)		2 : MDC(perpendicular to slit)Prompt mode "Mode:edc=0;mdc(para)=1,(perp)=2"string newname="Matrix3DName20"Prompt newname "New 3Dmat name (ex. 20, 21, 22)"variable pointnum2=7Prompt pointnum2 "(2nd order) Number of points"variable repetitionnum2=2Prompt repetitionnum2 "(2nd order) Number of repetitions"variable pointnum4=25Prompt pointnum4 "(4th order) Number of points"variable repetitionnum4=1Prompt repetitionnum4 "(4th order) Number of repetitions"variable pointnumb=25Prompt pointnumb "(Binominal) Number of points"variable repetitionnumb=1Prompt repetitionnumb "(Binominal) Number of repetitions"string mat3D="Matrix3DName"Prompt mat3D "Original 3D matrix name"PauseUpdate; Silent 1		// building window...Duplicate/O $mat3d,$newnamevariable i=0If(i<repetitionnum2)	Do		Smooth/E=0/DIM=(mode)/S=2 pointnum2, $newname		i+=1			while(i<repetitionnum2)endifi=0If(i<repetitionnum4)	Do		Smooth/E=0/DIM=(mode)/S=4 pointnum4, $newname		i+=1			while(i<repetitionnum4)endifi=0If(i<repetitionnumb)	Do		Smooth/E=0/DIM=(mode) pointnumb, $newname		i+=1			while(i<repetitionnumb)endifDifferentiate/DIM=(mode)  $newnameDifferentiate/DIM=(mode)  $newnameendFunction ButtonProc_3DMatrix_2deriv(ctrlname) : ButtonControlstring ctrlNameExecute "Twoaxis_Mat3D_2deriv()"End/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   Graphical Slicer   //////////////////////////////////////////////Window GS_Energy() : Graph	PauseUpdate; Silent 1		// building window...	Make/N=9/D/O coef_gs	coef_gs[0]=0			//Binding energy [eV]	coef_gs[1]=0.005		//Energy width to be integrated	coef_gs[2]=16.824		//Fermi energy	coef_gs[3]=180		//angle	coef_gs[4]=50			//start x csr	coef_gs[5]=50			//end c csr	coef_gs[6]=2			//number of slices to be added	coef_gs[7]=50			//一時的にstart x csrを保管	coef_gs[8]=50		//一時的にend x csrを保管	variable/G GS_energy_delta=0.01		Make/N=5/D/O cut_theta	Make/N=5/D/O cut_thetax	Make/N=5/D/O cut_phi	Make/N=5/D/O cut_phix	cut_theta=nan	cut_thetax=nan	cut_phi=nan	cut_phix=nan		Make/N=(15,15)/D/O Image2DName		PauseUpdate; Silent 1		// building window...	Display /W=(8,306,199,485) cut_phi vs cut_phix	AppendToGraph cut_theta vs cut_thetax	AppendImage Image2DName	ModifyImage Image2DName ctab= {*,*,Terrain,0}	ModifyGraph rgb=(0,0,65535)	ModifyGraph mirror=2	ControlBar 48	SetVariable setvar0,pos={5,3},size={92,18},proc=SetVarProc_GS_energy,title="B.E."	SetVariable setvar0,fSize=12,limits={-inf,inf,0.01},value= coef_gs[0]	GroupBox CBSeparator0,pos={0,48},size={181,4}	SetVariable setvar1,pos={97,3},size={45,18},proc=SetVarProc_GS_energy_delta,title=" "	SetVariable setvar1,fSize=12,limits={-inf,inf,0},value= GS_energy_delta	SetVariable setvar2,pos={5,25},size={102,18},proc=SetVarProc_GS_energy,title="width +/-"	SetVariable setvar2,fSize=12,limits={-inf,inf,0},value= coef_gs[1]	SetVariable setvar3,pos={111,25},size={72,18},proc=SetVarProc_GS_energy,title="EF"	SetVariable setvar3,fSize=12,limits={-inf,inf,0},value= coef_gs[2]	Button button2,pos={147,2},size={15,20},proc=ButtonProc_GS_energy_duplicate,title="D"	Button button2,fSize=12EndMacroFunction SetVarProc_GS_energy(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	String/G GS_mat3Dname		Execute"Twoaxis_GS_energy()"	EndFunction SetVarProc_GS_energy_delta(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G GS_energy_delta			SetVariable setvar0 limits={-Inf,Inf,GS_energy_delta}EndFunction ButtonProc_GS_energy_duplicate(ctrlName) : ButtonControl	String ctrlName		Execute"GS_energy_duplicate()"EndMacro Twoaxis_GS_energy()	//3DmatrixからFS intensity plotを抜き出す    Graphical Slicer用		X=theta, Y=energy (originalのushimacroとX, Yが反転している)  or  X=kx, Y=ky	variable BE=coef_gs[0]		//Binding Energy[eV]	variable Ewidth=coef_gs[1]	//積分範囲[eV]	variable EF=coef_gs[2]		//EFのKineticEnergy[eV]	String ImageName="Image2DName"	String Mat3DName=GS_mat3DName	//どの3Dmatrixを読み込むか選択PauseUpdate;Silent 1	variable Edelta=Dimdelta($Mat3DName,0)	variable E0=Dimoffset($Mat3DName,0)	variable Estart=round((EF+BE-E0-Ewidth)/Edelta)	variable Eend=round((EF+BE-E0+Ewidth)/Edelta)		Make/N=(Dimsize($Mat3Dname,2),Dimsize($Mat3Dname,1))/D/O $ImageName		SetScale/P x Dimoffset($Mat3Dname,2),Dimdelta($Mat3Dname,2),"", $ImageName	SetScale/P y Dimoffset($Mat3Dname,1),Dimdelta($Mat3Dname,1),"", $ImageNamePauseUpdate;Silent 1		$ImageName=0	GS_SumFS(Estart, Eend, $ImageName, $Mat3Dname)		endmacrofunction GS_SumFS(i, j, Mat2D, Mat3D)	wave Mat2D, Mat3D	variable i, j		Do	Mat2D[][]+=Mat3D[i][q][p]	i+=1	while (i<j+1)endmacro GS_energy_duplicate(matname)string matname="Matrixname"PauseUpdate;Silent 1duplicate/o Image2DName $matnamedisplay;appendimage $matnameModifyImage $matname ctab= {*,*,Terrain,0}endWindow GS_Theta() : Graph	Make/N=(15,15)/D/O ImageAngle	variable/G GS_Theta_delta=1	variable/G GS_theta_energy=1	PauseUpdate; Silent 1		// building window...	Display /W=(202,306,419,566)	AppendImage ImageAngle	ModifyImage ImageAngle ctab= {*,*,Terrain,0}	ModifyGraph mirror=2	ControlBar 26	SetVariable setvar0,pos={5,3},size={90,18},proc=SetVarProc_GS_theta,title="Angle"	SetVariable setvar0,fSize=12,limits={-inf,inf,1},value= coef_gs[3]	PopupMenu popup1,pos={124,3},size={49,17},proc=PopMenuProc_GS_theta_energy	PopupMenu popup1,mode=1,popvalue="K.E.",value= #"\"K.E.;B.E.\""	Button button2,pos={179,2},size={15,20},proc=ButtonProc_GS_theta_duplicate,title="D"	Button button2,fSize=12	SetVariable setvar1,pos={95,3},size={25,18},proc=SetVarProc_GS_Theta_delta,title=" "	SetVariable setvar1,fSize=12,limits={-inf,inf,0},value= gs_theta_delta	ModifyGraph swapXY=1EndMacroFunction SetVarProc_GS_theta(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		Execute "Twoaxis_cuts_theta()"	Execute "update_cuts_GS_theta()"EndFunction SetVarProc_GS_Theta_delta(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G GS_theta_delta			SetVariable setvar0 limits={-Inf,Inf,GS_theta_delta}EndFunction PopMenuProc_GS_theta_energy(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	variable/G GS_theta_energy	switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch	GS_theta_energy=popNum	Execute "Twoaxis_cuts_theta()"EndFunction ButtonProc_GS_theta_duplicate(ctrlName) : ButtonControl	String ctrlName		Execute"GS_theta_duplicate()"EndMacro Twoaxis_cuts_theta()	//3Dmatrixを元に2Dintensityを作製   graphical slicer用 (theta用)	variable centerangle=coef_gs[3]	//auto cutする際の中心となる角度	variable shiftEF=coef_gs[2]	//EF補正	String cutname="cut"		string Mat3D = GS_mat3DnamePauseUpdate;Silent 1		variable Angledelta=Dimdelta($Mat3D,2)	variable Angle0=Dimoffset($Mat3D,2)	variable StartAngle=round((centerangle-angle0)/Angledelta)		String Addname	Addname="ImageAngle"if(GS_theta_energy==1)	Make/N=(Dimsize($Mat3D,0), Dimsize($Mat3D,1)) /D/O $Addname	SetScale/P x Dimoffset($Mat3D,0),Dimdelta($Mat3D,0),"", $Addname; DelayUpdate		//2Dマトリックスのxwave scaleの定義	SetScale/P y Dimoffset($Mat3D,1),Dimdelta($Mat3D,1),"", $Addname	else	Make/N=(Dimsize($Mat3D,0), Dimsize($Mat3D,1)) /D/O $Addname	SetScale/P x (Dimoffset($Mat3D,0)-coef_gs[2]),Dimdelta($Mat3D,0),"", $Addname; DelayUpdate		//2Dマトリックスのxwave scaleの定義	SetScale/P y Dimoffset($Mat3D,1),Dimdelta($Mat3D,1),"", $Addname	endif	$Addname=0	$Addname[][]=$Mat3D[p][q][Startangle]		End Macromacro GS_theta_duplicate(matname)string matname="Matrixname"PauseUpdate;Silent 1duplicate/o ImageAngle $matnamedisplay;appendimage $matnameModifyImage $matname ctab= {*,*,Terrain,0}endmacro update_cuts_GS_theta()PauseUpdate;Silent 1	String Mat3D=GS_mat3Dnamecut_thetax[0]=coef_gs[3]+Dimdelta($mat3D,2)/2cut_thetax[1]=coef_gs[3]+Dimdelta($mat3D,2)/2cut_thetax[3]=coef_gs[3]-Dimdelta($mat3D,2)/2cut_thetax[4]=coef_gs[3]-Dimdelta($mat3D,2)/2cut_theta[0]=Dimoffset($mat3D,1)-Dimdelta($mat3D,1)/2cut_theta[1]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(Dimsize($mat3D,1)-0.5)cut_theta[3]=Dimoffset($mat3D,1)-Dimdelta($mat3D,1)/2cut_theta[4]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(Dimsize($mat3D,1)-0.5)endWindow GS_Phi() : Graph	Make/N=(15,15)/D/O Imagecut	variable/G GS_phi_delta=5	variable/G GS_phi_change=1	variable/G GS_phi_energy=1	PauseUpdate; Silent 1		// building window...	Display /W=(422,306,640,566)	AppendImage Imagecut	ModifyImage Imagecut ctab= {*,*,Terrain,0}	ModifyGraph mirror=2	ControlBar 48	SetVariable Start,pos={6,3},size={85,18},proc=SetVarProc_GS_phi_start,title="Start"	SetVariable Start,fSize=12,limits={-inf,inf,5},value= coef_gs[4]	SetVariable End,pos={91,3},size={79,18},proc=SetVarProc_GS_phi_end,title="End"	SetVariable End,fSize=12,limits={-inf,inf,5},value= coef_gs[5]	SetVariable setvar1,pos={170,3},size={25,18},proc=SetVarProc_GS_Phi_delta,title=" "	SetVariable setvar1,fSize=12,limits={-inf,inf,0},value= gs_phi_delta	SetVariable Width,pos={5,25},size={90,18},proc=SetVarProc_GS_phi_width,title="width +/-"	SetVariable Width,fSize=12,limits={-inf,inf,0},value= coef_gs[6]	PopupMenu popup0,pos={99,25},size={55,17},proc=PopMenuProc_GS_phi_change	PopupMenu popup0,mode=1,popvalue="Both",value= #"\"Both;One\""	PopupMenu popup1,pos={158,25},size={49,17},proc=PopMenuProc_GS_phi_energy	PopupMenu popup1,mode=1,popvalue="K.E.",value= #"\"K.E.;B.E.\""	Button button2,pos={200,2},size={15,20},proc=ButtonProc_GS_phi_duplicate,title="D"	Button button2,fSize=12	ModifyGraph swapXY=1EndMacroFunction SetVarProc_GS_phi_start(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	wave coef_gs	variable/G GS_phi_change	If (GS_phi_change==1)	coef_gs[5]+=coef_gs[4]-coef_gs[7]		coef_gs[8]=coef_gs[5]	endif		Execute "twoaxis_cuts_phi()"	Execute "update_cuts_GS_phi()"	coef_gs[7]=coef_gs[4]	EndFunction SetVarProc_GS_phi_end(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	wave coef_gs	variable/G GS_phi_change	If (GS_phi_change==1)	coef_gs[4]+=coef_gs[5]-coef_gs[8]		coef_gs[7]=coef_gs[4]	endif		Execute "twoaxis_cuts_phi()"	Execute "update_cuts_GS_phi()"	coef_gs[8]=coef_gs[5]	EndFunction SetVarProc_GS_Phi_delta(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G GS_phi_delta			SetVariable start limits={-Inf,Inf,GS_phi_delta}	SetVariable end limits={-Inf,Inf,GS_phi_delta}EndFunction SetVarProc_GS_phi_width(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	wave coef_gs	Execute "Twoaxis_cuts_phi()"	Execute "update_cuts_GS_phi()"EndFunction PopMenuProc_GS_phi_change(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	variable/G GS_phi_change	switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch	GS_phi_change=popNum	EndFunction PopMenuProc_GS_phi_energy(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	variable/G GS_phi_energy	switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch	GS_phi_energy=popNum		Execute "Twoaxis_cuts_phi()"EndMacro Twoaxis_cuts_phi()	//3Dmatrixを元に2Dintensityを作製   graphical slicer用_(phi用)_斜め切り対応	variable Xstart=coef_gs[4],Xend=coef_gs[5]	variable width=coef_gs[6]	//cutする際に足し合わせるedcの数	variable shiftEF=coef_gs[2]	//EF補正		String Mat3D=GS_mat3Dname	String Addname	Addname="Imagecut"PauseUpdate;Silent 1if(GS_phi_energy==1)	Make/N=(Dimsize($Mat3D,0), Dimsize($Mat3D,2)) /D/O $Addname	SetScale/P x Dimoffset($Mat3D,0),Dimdelta($Mat3D,0),"", $Addname; DelayUpdate		//2Dマトリックスのxwave scaleの定義	SetScale/P y Dimoffset($Mat3D,2),Dimdelta($Mat3D,2),"", $Addname	else	Make/N=(Dimsize($Mat3D,0), Dimsize($Mat3D,2)) /D/O $Addname	SetScale/P x (Dimoffset($Mat3D,0)-coef_gs[2]),Dimdelta($Mat3D,0),"", $Addname; DelayUpdate		//2Dマトリックスのxwave scaleの定義	SetScale/P y Dimoffset($Mat3D,2),Dimdelta($Mat3D,2),"", $Addname	endifvariable ydim=Dimsize($Mat3D,2)	$Addname=0	Twoaxis_cuts_phi_func($Addname, $Mat3D, Xstart, Xend, -width, ydim)		End MacroFunction Twoaxis_cuts_phi_func(Mat2D, Mat3D, Xstart, Xend, startslice, ydim)	wave Mat2D, Mat3D	variable Xstart, Xend	variable startslice	variable ydim	variable lastslice=-startslice		Do	Mat2D[][]+=Mat3D[p][Xstart+round(q*(Xend-Xstart)/ydim)+startslice][q]	startslice+=1	While (startslice<lastslice+1)Endmacro update_cuts_GS_phi()PauseUpdate;Silent 1	String Mat3D=GS_mat3Dnamecut_phix[0]=Dimoffset($mat3D,2)-Dimdelta($mat3D,2)/2cut_phix[1]=Dimoffset($mat3D,2)+Dimdelta($mat3D,2)*(Dimsize($mat3D,2)-0.5)cut_phix[3]=Dimoffset($mat3D,2)-Dimdelta($mat3D,2)/2cut_phix[4]=Dimoffset($mat3D,2)+Dimdelta($mat3D,2)*(Dimsize($mat3D,2)-0.5)cut_phi[0]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(coef_gs[4]-coef_gs[6]-0.5)cut_phi[1]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(coef_gs[5]-coef_gs[6]-0.5)cut_phi[3]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(coef_gs[4]+coef_gs[6]+0.5)cut_phi[4]=Dimoffset($mat3D,1)+Dimdelta($mat3D,1)*(coef_gs[5]+coef_gs[6]+0.5)endmacro GS_phi_duplicate(matname)string matname="Matrixname"PauseUpdate;Silent 1duplicate/o Imagecut $matnamedisplay;appendimage $matnameModifyImage $matname ctab= {*,*,Terrain,0}endFunction ButtonProc_GS_phi_duplicate(ctrlName) : ButtonControl	String ctrlName		Execute"GS_phi_duplicate()"End////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   FS_mapping_window   ////////////////////////////////////////////////////Function PopMenuProc_FS_BZMode(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G FS_BZMode		switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		FS_BZMode=popNum	Execute "FS_drawZB()"	EndFunction PopMenuProc_FS_kunit(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G FS_kunit		switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		FS_kunit=popNum	Execute "FS_drawZB()"	Endmacro FS_drawZB()If(FS_BZMode==1&&FS_kunit==1)PauseUpdate; Silent 1	Redimension/N=23 ZB,ZBxZB=nanZBx=nanZB[0]=-3*pi/FSmap_coef[2]ZB[1]=3*pi/FSmap_coef[2]ZB[3]=-3*pi/FSmap_coef[2]ZB[4]=3*pi/FSmap_coef[2]ZB[6]=-3*pi/FSmap_coef[2]ZB[7]=3*pi/FSmap_coef[2]ZB[9]=-3*pi/FSmap_coef[2]ZB[10]=3*pi/FSmap_coef[2]ZB[12]=3*pi/FSmap_coef[2]ZB[13]=3*pi/FSmap_coef[2]ZB[15]=1*pi/FSmap_coef[2]ZB[16]=1*pi/FSmap_coef[2]ZB[18]=-1*pi/FSmap_coef[2]ZB[19]=-1*pi/FSmap_coef[2]ZB[21]=-3*pi/FSmap_coef[2]ZB[22]=-3*pi/FSmap_coef[2]ZBx[0]=-3*pi/FSmap_coef[1]ZBx[1]=-3*pi/FSmap_coef[1]ZBx[3]=-1*pi/FSmap_coef[1]ZBx[4]=-1*pi/FSmap_coef[1]ZBx[6]=1*pi/FSmap_coef[1]ZBx[7]=1*pi/FSmap_coef[1]ZBx[9]=3*pi/FSmap_coef[1]ZBx[10]=3*pi/FSmap_coef[1]ZBx[12]=-3*pi/FSmap_coef[1]ZBx[13]=3*pi/FSmap_coef[1]ZBx[15]=-3*pi/FSmap_coef[1]ZBx[16]=3*pi/FSmap_coef[1]ZBx[18]=-3*pi/FSmap_coef[1]ZBx[19]=3*pi/FSmap_coef[1]ZBx[21]=-3*pi/FSmap_coef[1]ZBx[22]=3*pi/FSmap_coef[1]endifIf(FS_BZMode==1&&FS_kunit==2)PauseUpdate; Silent 1	Redimension/N=23 ZB,ZBxZB=nanZBx=nanZB[0]=-3ZB[1]=3ZB[3]=-3ZB[4]=3ZB[6]=-3ZB[7]=3ZB[9]=-3ZB[10]=3ZB[12]=3ZB[13]=3ZB[15]=1ZB[16]=1ZB[18]=-1ZB[19]=-1ZB[21]=-3ZB[22]=-3ZBx[0]=-3ZBx[1]=-3ZBx[3]=-1ZBx[4]=-1ZBx[6]=1ZBx[7]=1ZBx[9]=3ZBx[10]=3ZBx[12]=-3ZBx[13]=3ZBx[15]=-3ZBx[16]=3ZBx[18]=-3ZBx[19]=3ZBx[21]=-3ZBx[22]=3endifIf(FS_BZMode==2&&FS_kunit==1)PauseUpdate; Silent 1	Redimension/N=23 ZB,ZBxZB=nanZBx=nanZB[0]=0ZB[1]=-3*sqrt(2)*pi/FSmap_coef[2]ZB[3]=sqrt(2)*pi/FSmap_coef[2]ZB[4]=-2*sqrt(2)*pi/FSmap_coef[2]ZB[6]=2*sqrt(2)*pi/FSmap_coef[2]ZB[7]=-sqrt(2)*pi/FSmap_coef[2]ZB[9]=3*sqrt(2)*pi/FSmap_coef[2]ZB[10]=0ZB[12]=0ZB[13]=3*sqrt(2)*pi/FSmap_coef[2]ZB[15]=-sqrt(2)*pi/FSmap_coef[2]ZB[16]=2*sqrt(2)*pi/FSmap_coef[2]ZB[18]=-2*sqrt(2)*pi/FSmap_coef[2]ZB[19]=sqrt(2)*pi/FSmap_coef[2]ZB[21]=-3*sqrt(2)*pi/FSmap_coef[2]ZB[22]=0ZBx[0]=-3*sqrt(2)*pi/FSmap_coef[1]ZBx[1]=0ZBx[3]=-2*sqrt(2)*pi/FSmap_coef[1]ZBx[4]=sqrt(2)*pi/FSmap_coef[1]ZBx[6]=-1*sqrt(2)*pi/FSmap_coef[1]ZBx[7]=2*sqrt(2)*pi/FSmap_coef[1]ZBx[9]=0ZBx[10]=3*sqrt(2)*pi/FSmap_coef[1]ZBx[12]=-3*sqrt(2)*pi/FSmap_coef[1]ZBx[13]=0ZBx[15]=-2*sqrt(2)*pi/FSmap_coef[1]ZBx[16]=sqrt(2)*pi/FSmap_coef[1]ZBx[18]=-1*sqrt(2)*pi/FSmap_coef[1]ZBx[19]=2*sqrt(2)*pi/FSmap_coef[1]ZBx[21]=0ZBx[22]=3*sqrt(2)*pi/FSmap_coef[1]endifIf(FS_BZMode==2&&FS_kunit==2)PauseUpdate; Silent 1	Redimension/N=23 ZB,ZBxZB=nanZBx=nanZB[0]=0ZB[1]=-3*sqrt(2)ZB[3]=sqrt(2)ZB[4]=-2*sqrt(2)ZB[6]=2*sqrt(2)ZB[7]=-sqrt(2)ZB[9]=3*sqrt(2)ZB[10]=0ZB[12]=0ZB[13]=3*sqrt(2)ZB[15]=-sqrt(2)ZB[16]=2*sqrt(2)ZB[18]=-2*sqrt(2)ZB[19]=sqrt(2)ZB[21]=-3*sqrt(2)ZB[22]=0ZBx[0]=-3*sqrt(2)ZBx[1]=0ZBx[3]=-2*sqrt(2)ZBx[4]=sqrt(2)ZBx[6]=-1*sqrt(2)ZBx[7]=2*sqrt(2)ZBx[9]=0ZBx[10]=3*sqrt(2)ZBx[12]=-3*sqrt(2)ZBx[13]=0ZBx[15]=-2*sqrt(2)ZBx[16]=sqrt(2)ZBx[18]=-1*sqrt(2)ZBx[19]=2*sqrt(2)ZBx[21]=0ZBx[22]=3*sqrt(2)endifIf(FS_BZMode==3&&FS_kunit==1)PauseUpdate; Silent 1	Redimension/N=41 ZB,ZBxZB=nanZBx=nanZB[0]=2/sqrt(3)*pi/FSmap_coef[2]ZB[1]=1/sqrt(3)*pi/FSmap_coef[2]ZB[2]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[3]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[4]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[5]=1/sqrt(3)*pi/FSmap_coef[2]ZB[6]=2/sqrt(3)*pi/FSmap_coef[2]ZB[7]=4/sqrt(3)*pi/FSmap_coef[2]ZB[8]=5/sqrt(3)*pi/FSmap_coef[2]ZB[9]=4/sqrt(3)*pi/FSmap_coef[2]ZB[10]=2/sqrt(3)*pi/FSmap_coef[2]ZB[11]=1/sqrt(3)*pi/FSmap_coef[2]ZB[13]=2/sqrt(3)*pi/FSmap_coef[2]ZB[14]=1/sqrt(3)*pi/FSmap_coef[2]ZB[15]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[16]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[17]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[19]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[20]=-4/sqrt(3)*pi/FSmap_coef[2]ZB[21]=-5/sqrt(3)*pi/FSmap_coef[2]ZB[22]=-4/sqrt(3)*pi/FSmap_coef[2]ZB[23]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[25]=-4/sqrt(3)*pi/FSmap_coef[2]ZB[26]=-5/sqrt(3)*pi/FSmap_coef[2]ZB[27]=-4/sqrt(3)*pi/FSmap_coef[2]ZB[28]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[29]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[31]=-2/sqrt(3)*pi/FSmap_coef[2]ZB[32]=-1/sqrt(3)*pi/FSmap_coef[2]ZB[33]=1/sqrt(3)*pi/FSmap_coef[2]ZB[34]=2/sqrt(3)*pi/FSmap_coef[2]ZB[35]=1/sqrt(3)*pi/FSmap_coef[2]ZB[37]=2/sqrt(3)*pi/FSmap_coef[2]ZB[38]=4/sqrt(3)*pi/FSmap_coef[2]ZB[39]=5/sqrt(3)*pi/FSmap_coef[2]ZB[40]=4/sqrt(3)*pi/FSmap_coef[2]ZBx[0]=0ZBx[1]=1*pi/FSmap_coef[1]ZBx[2]=1*pi/FSmap_coef[1]ZBx[3]=0ZBx[4]=-1*pi/FSmap_coef[1]ZBx[5]=-1*pi/FSmap_coef[1]ZBx[6]=0ZBx[7]=0ZBx[8]=1*pi/FSmap_coef[1]ZBx[9]=2*pi/FSmap_coef[1]ZBx[10]=2*pi/FSmap_coef[1]ZBx[11]=1*pi/FSmap_coef[1]ZBx[13]=2*pi/FSmap_coef[1]ZBx[14]=3*pi/FSmap_coef[1]ZBx[15]=3*pi/FSmap_coef[1]ZBx[16]=2*pi/FSmap_coef[1]ZBx[17]=1*pi/FSmap_coef[1]ZBx[19]=2*pi/FSmap_coef[1]ZBx[20]=2*pi/FSmap_coef[1]ZBx[21]=1*pi/FSmap_coef[1]ZBx[22]=0ZBx[23]=0ZBx[25]=0ZBx[26]=-1*pi/FSmap_coef[1]ZBx[27]=-2*pi/FSmap_coef[1]ZBx[28]=-2*pi/FSmap_coef[1]ZBx[29]=-1*pi/FSmap_coef[1]ZBx[31]=-2*pi/FSmap_coef[1]ZBx[32]=-3*pi/FSmap_coef[1]ZBx[33]=-3*pi/FSmap_coef[1]ZBx[34]=-2*pi/FSmap_coef[1]ZBx[35]=-1*pi/FSmap_coef[1]ZBx[37]=-2*pi/FSmap_coef[1]ZBx[38]=-2*pi/FSmap_coef[1]ZBx[39]=-1*pi/FSmap_coef[1]ZBx[40]=0endifIf(FS_BZMode==3&&FS_kunit==2)PauseUpdate; Silent 1	Redimension/N=41 ZB,ZBxZB=nanZBx=nanZB[0]=2/sqrt(3)ZB[1]=1/sqrt(3)ZB[2]=-1/sqrt(3)ZB[3]=-2/sqrt(3)ZB[4]=-1/sqrt(3)ZB[5]=1/sqrt(3)ZB[6]=2/sqrt(3)ZB[7]=4/sqrt(3)ZB[8]=5/sqrt(3)ZB[9]=4/sqrt(3)ZB[10]=2/sqrt(3)ZB[11]=1/sqrt(3)ZB[13]=2/sqrt(3)ZB[14]=1/sqrt(3)ZB[15]=-1/sqrt(3)ZB[16]=-2/sqrt(3)ZB[17]=-1/sqrt(3)ZB[19]=-2/sqrt(3)ZB[20]=-4/sqrt(3)ZB[21]=-5/sqrt(3)ZB[22]=-4/sqrt(3)ZB[23]=-2/sqrt(3)ZB[25]=-4/sqrt(3)ZB[26]=-5/sqrt(3)ZB[27]=-4/sqrt(3)ZB[28]=-2/sqrt(3)ZB[29]=-1/sqrt(3)ZB[31]=-2/sqrt(3)ZB[32]=-1/sqrt(3)ZB[33]=1/sqrt(3)ZB[34]=2/sqrt(3)ZB[35]=1/sqrt(3)ZB[37]=2/sqrt(3)ZB[38]=4/sqrt(3)ZB[39]=5/sqrt(3)ZB[40]=4/sqrt(3)ZBx[0]=0ZBx[1]=1ZBx[2]=1ZBx[3]=0ZBx[4]=-1ZBx[5]=-1ZBx[6]=0ZBx[7]=0ZBx[8]=1ZBx[9]=2ZBx[10]=2ZBx[11]=1ZBx[13]=2ZBx[14]=3ZBx[15]=3ZBx[16]=2ZBx[17]=1ZBx[19]=2ZBx[20]=2ZBx[21]=1ZBx[22]=0ZBx[23]=0ZBx[25]=0ZBx[26]=-1ZBx[27]=-2ZBx[28]=-2ZBx[29]=-1ZBx[31]=-2ZBx[32]=-3ZBx[33]=-3ZBx[34]=-2ZBx[35]=-1ZBx[37]=-2ZBx[38]=-2ZBx[39]=-1ZBx[40]=0endifIf(FS_BZMode==4&&FS_kunit==1)PauseUpdate; Silent 1	Redimension/N=41 ZB,ZBxZB=nanZBx=nanZB[0]=0ZB[1]=1*pi/FSmap_coef[2]ZB[2]=1*pi/FSmap_coef[2]ZB[3]=0ZB[4]=-1*pi/FSmap_coef[2]ZB[5]=-1*pi/FSmap_coef[2]ZB[6]=0ZB[7]=0ZB[8]=1*pi/FSmap_coef[2]ZB[9]=2*pi/FSmap_coef[2]ZB[10]=2*pi/FSmap_coef[2]ZB[11]=1*pi/FSmap_coef[2]ZB[13]=2*pi/FSmap_coef[2]ZB[14]=3*pi/FSmap_coef[2]ZB[15]=3*pi/FSmap_coef[2]ZB[16]=2*pi/FSmap_coef[2]ZB[17]=1*pi/FSmap_coef[2]ZB[19]=2*pi/FSmap_coef[2]ZB[20]=2*pi/FSmap_coef[2]ZB[21]=1*pi/FSmap_coef[2]ZB[22]=0ZB[23]=0ZB[25]=0ZB[26]=-1*pi/FSmap_coef[2]ZB[27]=-2*pi/FSmap_coef[2]ZB[28]=-2*pi/FSmap_coef[2]ZB[29]=-1*pi/FSmap_coef[2]ZB[31]=-2*pi/FSmap_coef[2]ZB[32]=-3*pi/FSmap_coef[2]ZB[33]=-3*pi/FSmap_coef[2]ZB[34]=-2*pi/FSmap_coef[2]ZB[35]=-1*pi/FSmap_coef[2]ZB[37]=-2*pi/FSmap_coef[2]ZB[38]=-2*pi/FSmap_coef[2]ZB[39]=-1*pi/FSmap_coef[2]ZB[40]=0ZBx[0]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[1]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[2]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[3]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[4]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[5]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[6]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[7]=4/sqrt(3)*pi/FSmap_coef[1]ZBx[8]=5/sqrt(3)*pi/FSmap_coef[1]ZBx[9]=4/sqrt(3)*pi/FSmap_coef[1]ZBx[10]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[11]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[13]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[14]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[15]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[16]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[17]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[19]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[20]=-4/sqrt(3)*pi/FSmap_coef[1]ZBx[21]=-5/sqrt(3)*pi/FSmap_coef[1]ZBx[22]=-4/sqrt(3)*pi/FSmap_coef[1]ZBx[23]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[25]=-4/sqrt(3)*pi/FSmap_coef[1]ZBx[26]=-5/sqrt(3)*pi/FSmap_coef[1]ZBx[27]=-4/sqrt(3)*pi/FSmap_coef[1]ZBx[28]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[29]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[31]=-2/sqrt(3)*pi/FSmap_coef[1]ZBx[32]=-1/sqrt(3)*pi/FSmap_coef[1]ZBx[33]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[34]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[35]=1/sqrt(3)*pi/FSmap_coef[1]ZBx[37]=2/sqrt(3)*pi/FSmap_coef[1]ZBx[38]=4/sqrt(3)*pi/FSmap_coef[1]ZBx[39]=5/sqrt(3)*pi/FSmap_coef[1]ZBx[40]=4/sqrt(3)*pi/FSmap_coef[1]endifIf(FS_BZMode==4&&FS_kunit==2)PauseUpdate; Silent 1	Redimension/N=41 ZB,ZBxZB=nanZBx=nanZB[0]=0ZB[1]=1ZB[2]=1ZB[3]=0ZB[4]=-1ZB[5]=-1ZB[6]=0ZB[7]=0ZB[8]=1ZB[9]=2ZB[10]=2ZB[11]=1ZB[13]=2ZB[14]=3ZB[15]=3ZB[16]=2ZB[17]=1ZB[19]=2ZB[20]=2ZB[21]=1ZB[22]=0ZB[23]=0ZB[25]=0ZB[26]=-1ZB[27]=-2ZB[28]=-2ZB[29]=-1ZB[31]=-2ZB[32]=-3ZB[33]=-3ZB[34]=-2ZB[35]=-1ZB[37]=-2ZB[38]=-2ZB[39]=-1ZB[40]=0ZBx[0]=2/sqrt(3)ZBx[1]=1/sqrt(3)ZBx[2]=-1/sqrt(3)ZBx[3]=-2/sqrt(3)ZBx[4]=-1/sqrt(3)ZBx[5]=1/sqrt(3)ZBx[6]=2/sqrt(3)ZBx[7]=4/sqrt(3)ZBx[8]=5/sqrt(3)ZBx[9]=4/sqrt(3)ZBx[10]=2/sqrt(3)ZBx[11]=1/sqrt(3)ZBx[13]=2/sqrt(3)ZBx[14]=1/sqrt(3)ZBx[15]=-1/sqrt(3)ZBx[16]=-2/sqrt(3)ZBx[17]=-1/sqrt(3)ZBx[19]=-2/sqrt(3)ZBx[20]=-4/sqrt(3)ZBx[21]=-5/sqrt(3)ZBx[22]=-4/sqrt(3)ZBx[23]=-2/sqrt(3)ZBx[25]=-4/sqrt(3)ZBx[26]=-5/sqrt(3)ZBx[27]=-4/sqrt(3)ZBx[28]=-2/sqrt(3)ZBx[29]=-1/sqrt(3)ZBx[31]=-2/sqrt(3)ZBx[32]=-1/sqrt(3)ZBx[33]=1/sqrt(3)ZBx[34]=2/sqrt(3)ZBx[35]=1/sqrt(3)ZBx[37]=2/sqrt(3)ZBx[38]=4/sqrt(3)ZBx[39]=5/sqrt(3)ZBx[40]=4/sqrt(3)endifendFunction ButtonProc_FS_FSmap_editpara(ctrlName) : ButtonControl	String ctrlName		Execute "FS_FSmap_editpara()"	Endmacro FS_FSmap_editpara()pauseupdate; silent 1Make/N=15/T/O text_FSmap_coeftext_FSmap_coef[0]="Ek"text_FSmap_coef[1]="a"text_FSmap_coef[2]="b"text_FSmap_coef[3]="ang.acceptance"text_FSmap_coef[4]="theta"text_FSmap_coef[5]="thetaoffset"text_FSmap_coef[6]="tilt"text_FSmap_coef[7]="tiltoffset"text_FSmap_coef[8]="azimuth"text_FSmap_coef[9]="azimuthoffset"text_FSmap_coef[10]="slicenum"text_FSmap_coef[11]="hmesh"text_FSmap_coef[12]="vmesh"text_FSmap_coef[13]="interp.factorh"text_FSmap_coef[14]="interp.factorv"Edit/W=(5,44,272,343) text_FSmap_coef,FSmap_coefendFunction PopMenuProc_FS_cuts_mode(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G FS_cuts_mode		switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		FS_cuts_mode=popNum	EndFunction ButtonProc_FS_cuts_reqadpara(ctrlName) : ButtonControlstring ctrlNameexecute "FS_cuts_readpara()"Endmacro FS_cuts_readpara()pauseupdate; silent 1cuts_coef[0]=FSmap_coef[0]cuts_coef[1]=FSmap_coef[1]cuts_coef[2]=FSmap_coef[2]cuts_coef[3]=FSmap_coef[3]cuts_coef[4]=FSmap_coef[4]cuts_coef[5]=FSmap_coef[5]cuts_coef[6]=FSmap_coef[6]cuts_coef[7]=FSmap_coef[7]cuts_coef[8]=FSmap_coef[8]cuts_coef[9]=FSmap_coef[9]endFunction ButtonProc_FS_cuts_editpara(ctrlName) : ButtonControl	String ctrlName		Execute "FS_cuts_editpara()"	Endmacro FS_cuts_editpara()pauseupdate; silent 1Make/N=15/T/O text_cuts_coeftext_cuts_coef[0]="Ek"text_cuts_coef[1]="a"text_cuts_coef[2]="b"text_cuts_coef[3]="ang.acceptance"text_cuts_coef[4]="theta"text_cuts_coef[5]="thetaoffset"text_cuts_coef[6]="tilt"text_cuts_coef[7]="tiltoffset"text_cuts_coef[8]="azimuth"text_cuts_coef[9]="azimuthoffset"text_cuts_coef[10]="startangle"text_cuts_coef[11]="stepangle"text_cuts_coef[12]="cutnum"text_cuts_coef[13]="cutnum_temp"text_cuts_coef[14]="FSangle"Edit/W=(5,44,272,361) text_cuts_coef,cuts_coefendMacro FS_cuts_theta()variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_thetawavecuts_thetawave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[5]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable tilt=cuts_coef[6]+cuts_coef[7]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(azimuth*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(-sqrt(ek/3.81283)*sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(azimuth*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(-sqrt(ek/3.81283)*sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_theta_perp()			//FS_cuts_thetaのperpendicular mode版variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_thetawavecuts_thetawave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[5]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1	//FSkxky macroと同様に符号反転variable tilt=cuts_coef[6]+cuts_coef[7]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(cuts_thetawave[i]*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(cuts_thetawave[i]*rad)*sin(cuts_deltawave[p]*rad)-sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(cuts_thetawave[i]*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(cuts_thetawave[i]*rad)*sin(cuts_deltawave[p]*rad)-sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_theta2()		//基本的にFS_cuts_theta()と同じ、ただし作成したcutをgraphにappendするvariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_thetawavecuts_thetawave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[5]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable tilt=cuts_coef[6]+cuts_coef[7]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(azimuth*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(-sqrt(ek/3.81283)*sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(azimuth*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(-sqrt(ek/3.81283)*sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_theta2_perp()		//基本的にFS_cuts_theta()と同じ、ただし作成したcutをgraphにappendする	(perpendicular mode)variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_thetawavecuts_thetawave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[5]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1		//FSkxky macroと同様に符号反転variable tilt=cuts_coef[6]+cuts_coef[7]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(cuts_thetawave[i]*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(cuts_thetawave[i]*rad)*sin(cuts_deltawave[p]*rad)-sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(cuts_thetawave[i]*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(cuts_thetawave[i]*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(cuts_thetawave[i]*rad)*sin(cuts_deltawave[p]*rad)-sin(cuts_thetawave[i]*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_tilt()variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_tiltwavecuts_tiltwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[7]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable theta=cuts_coef[4]+cuts_coef[5]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(azimuth*rad)*(sqrt(ek/3.81283)*(cos(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(azimuth*rad)*(sqrt(ek/3.81283)*(cos(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_tilt_perp()		//FS_cuts_tiltの perpendicular modevariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_tiltwavecuts_tiltwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[7]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1		//FSkxky macroと同様の理由で符号反転variable theta=cuts_coef[4]+cuts_coef[5]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_tilt2()			//FS_cuts_tilt()と同じ、ただし作成したcutをgraphにappendするvariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_tiltwavecuts_tiltwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[7]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable theta=cuts_coef[4]+cuts_coef[5]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(azimuth*rad)*(sqrt(ek/3.81283)*(cos(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(azimuth*rad)*(sqrt(ek/3.81283)*(cos(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_tilt2_perp()			//FS_cuts_tilt()と同じ、ただし作成したcutをgraphにappendするvariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_tiltwavecuts_tiltwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[7]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1		//FSkxkyと同じ理由により符号反転variable theta=cuts_coef[4]+cuts_coef[5]variable azimuth=cuts_coef[8]+cuts_coef[9]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))+sin(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin((azimuth)*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(cuts_tiltwave[i]*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(cuts_tiltwave[i]*rad)*cos(cuts_deltawave[p]*rad)))-cos(azimuth*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_azimuth()variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_azimuthwavecuts_azimuthwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[9]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable theta=cuts_coef[4]+cuts_coef[5]variable tilt=cuts_coef[6]+cuts_coef[7]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(cuts_azimuthwave[i]*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(cuts_azimuthwave[i]*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(cuts_azimuthwave[i]*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(cuts_azimuthwave[i]*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_azimuth_perp()variable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_azimuthwavecuts_azimuthwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[9]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1		//FSkxkyと同じ理由により符号反転variable theta=cuts_coef[4]+cuts_coef[5]variable tilt=cuts_coef[6]+cuts_coef[7]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifi+=1While (i<cutNum)End MacroMacro FS_cuts_azimuth2()			//FS_cuts_azimuth()と同じ、ただし作成したcutをgraphにappendするvariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_azimuthwavecuts_azimuthwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[9]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xvariable theta=cuts_coef[4]+cuts_coef[5]variable tilt=cuts_coef[6]+cuts_coef[7]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(cuts_azimuthwave[i]*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(cuts_azimuthwave[i]*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))$cutxwavename[]=sin(cuts_azimuthwave[i]*rad)*(sqrt(ek/3.81283)*(cos(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(cuts_azimuthwave[i]*rad)*(-sqrt(ek/3.81283)*sin(theta*rad)*cos(cuts_deltawave[p]*rad))If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_azimuth2_perp()			//FS_cuts_azimuth()と同じ、ただし作成したcutをgraphにappendするvariable ek=cuts_coef[0]variable cutNum=cuts_coef[12]Make/N=(cutNum)/O cuts_azimuthwavecuts_azimuthwave=cuts_coef[10]+cuts_coef[11]*x+cuts_coef[9]Make/N=51/O cuts_deltawavecuts_deltawave=-0.5*cuts_coef[3]+cuts_coef[3]/50*xcuts_deltawave*=-1		//FSkxkyと同じ理由により符号反転variable theta=cuts_coef[4]+cuts_coef[5]variable tilt=cuts_coef[6]+cuts_coef[7]variable rad=pi/180String cutwavename,cutxwavenamepauseupdate; silent 1variable i=0Docutwavename="cut"+num2istr(i)cutxwavename="cut"+num2istr(i)+"x"make/N=51/O $cutwavename,$cutxwavename$cutwavename[]=cos(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))+sin(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kxの計算$cutxwavename[]=sin(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(sin(theta*rad)*sin(tilt*rad)*sin(cuts_deltawave[p]*rad)+cos(theta*rad)*sin(tilt*rad)*cos(cuts_deltawave[p]*rad)))-cos(cuts_azimuthwave[i]*rad)*(sqrt(Ek/3.81283)*(cos(theta*rad)*sin(cuts_deltawave[p]*rad)-sin(theta*rad)*cos(cuts_deltawave[p]*rad)))	//kyの計算If(FS_kunit==2)$cutwavename/=pi/cuts_coef[2]$cutxwavename/=pi/cuts_coef[1]endifappend $cutwavename vs $cutxwavenamei+=1While (i<cutNum)End MacroMacro FS_cuts_append()String cutwavename,cutxwavenamevariable cutnum=cuts_coef[12]variable i=0pauseupdate; silent 1Do	cutwavename="cut"+num2istr(i)	cutxwavename="cut"+num2istr(i)+"x"		append $cutwavename vs $cutxwavename			i+=1while(i<cutnum)endMacro FS_cuts_remove()string cutwavenamestring cutxwavenamevariable cutnum=cuts_coef[13]variable i=0pauseupdate; silent 1Do	cutwavename="cut"+num2istr(i)	cutxwavename="cut"+num2istr(i)+"x"	remove/Z $cutwavename	killwaves/Z $cutwavename	killwaves/Z $cutxwavename	i+=1while(i<cutnum)endFunction ButtonProc_FS_cuts_append(ctrlName) : ButtonControl	String ctrlName		execute"FS_cuts_append()"EndFunction ButtonProc_FS_cuts_remove(ctrlName) : ButtonControl	String ctrlName	execute"FS_cuts_remove()"Endmacro FS_edit_kFtable()	edit theta,tilt,azimuth,FS00a,FS00b,FSp0a,FSp0b,FSppa,FSppb	ModifyTable width=50	ModifyTable width(Point)=30endMacro  FS_kFkxky()variable rad=pi/180variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angleaccept=FSmap_coef[3]variable thetaoffset=FSmap_coef[5]variable tiltoffset=FSmap_coef[7]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]pauseupdate; silent 1	variable length			length=dimsize(theta,0)	redimension/N=(length,0) FS00a	redimension/N=(length,0) FS00b	redimension/N=(length,0) FSp0a	redimension/N=(length,0) FSp0b	redimension/N=(length,0) FSppa	redimension/N=(length,0) FSppb	duplicate/O FS00a delta	duplicate/O FS00a kFx	duplicate/O FS00a kFy	duplicate/O FS00a kx00a	duplicate/O FS00a ky00a	duplicate/O FS00a kx00b	duplicate/O FS00a ky00b	duplicate/O FS00a kxp0a	duplicate/O FS00a kyp0a	duplicate/O FS00a kxp0b	duplicate/O FS00a kyp0b	duplicate/O FS00a kxppa	duplicate/O FS00a kyppa	duplicate/O FS00a kxppb	duplicate/O FS00a kyppb		duplicate/O FS00a kx00af	duplicate/O FS00a ky00af	duplicate/O FS00a kx00bf	duplicate/O FS00a ky00bf	duplicate/O FS00a kxp0af	duplicate/O FS00a kyp0af	duplicate/O FS00a kxp0bf	duplicate/O FS00a kyp0bf	duplicate/O FS00a kxppaf	duplicate/O FS00a kyppaf	duplicate/O FS00a kxppbf	duplicate/O FS00a kyppbf		redimension/N=(length,8) kx00af	redimension/N=(length,8) ky00af	redimension/N=(length,8) kx00bf	redimension/N=(length,8) ky00bf	redimension/N=(length,16) kxp0af	redimension/N=(length,16) kyp0af	redimension/N=(length,16) kxp0bf	redimension/N=(length,16) kyp0bf	redimension/N=(length,16) kxppaf	redimension/N=(length,16) kyppaf	redimension/N=(length,16) kxppbf	redimension/N=(length,16) kyppbf		kx00af=nan	ky00af=nan	kx00bf=nan	ky00bf=nan	kxp0af=nan	kyp0af=nan	kxp0bf=nan	kyp0bf=nan	kxppaf=nan	kyppaf=nan	kxppbf=nan	kyppbf=nan			delta=angleaccept*(-0.5+FS00a/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	ky00a=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kx00a=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FS00b/(slicenum-1))	kFy=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	ky00b=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kx00b=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSp0a/(slicenum-1))	kFy=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	kyp0a=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxp0a=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSp0b/(slicenum-1))	kFy=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	kyp0b=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxp0b=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSppa/(slicenum-1))	kFy=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	kyppa=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxppa=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSppb/(slicenum-1))	kFy=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)													//kxの計算	kyppb=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxppb=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx	kx00af[][0]=abs(kx00a[p])			//kFを(0,0), (±pi,0), (±pi,±pi)を中心に回転、(0,0)は90度×4回、(±pi,0)と(±pi,±pi)は180度×2回	ky00af[][0]=abs(ky00a[p])	kx00af[][1]=cos(90*rad)*kx00af[p][0]-sin(90*rad)*ky00af[p][0]	ky00af[][1]=sin(90*rad)*kx00af[p][0]+cos(90*rad)*ky00af[p][0]	kx00af[][2]=cos(180*rad)*kx00af[p][0]-sin(180*rad)*ky00af[p][0]	ky00af[][2]=sin(180*rad)*kx00af[p][0]+cos(180*rad)*ky00af[p][0]	kx00af[][3]=cos(270*rad)*kx00af[p][0]-sin(270*rad)*ky00af[p][0]	ky00af[][3]=sin(270*rad)*kx00af[p][0]+cos(270*rad)*ky00af[p][0]	kx00bf[][0]=abs(kx00b[p])	ky00bf[][0]=abs(ky00b[p])	kx00bf[][1]=cos(90*rad)*kx00bf[p][0]-sin(90*rad)*ky00bf[p][0]	ky00bf[][1]=sin(90*rad)*kx00bf[p][0]+cos(90*rad)*ky00bf[p][0]	kx00bf[][2]=cos(180*rad)*kx00bf[p][0]-sin(180*rad)*ky00bf[p][0]	ky00bf[][2]=sin(180*rad)*kx00bf[p][0]+cos(180*rad)*ky00bf[p][0]	kx00bf[][3]=cos(270*rad)*kx00bf[p][0]-sin(270*rad)*ky00bf[p][0]	ky00bf[][3]=sin(270*rad)*kx00bf[p][0]+cos(270*rad)*ky00bf[p][0]	kxp0af[][0]=abs(kxp0a[p])	kyp0af[][0]=abs(kyp0a[p])	kxp0af[][1]=cos(180*rad)*(kxp0af[p][0]-pi/a0)-sin(180*rad)*kyp0af[p][0]+pi/a0	kyp0af[][1]=sin(180*rad)*(kxp0af[p][0]-pi/a0)+cos(180*rad)*kyp0af[p][0]	kxp0bf[][0]=abs(kxp0b[p])	kyp0bf[][0]=abs(kyp0b[p])	kxp0bf[][1]=cos(180*rad)*(kxp0bf[p][0]-pi/a0)-sin(180*rad)*kyp0bf[p][0]+pi/a0	kyp0bf[][1]=sin(180*rad)*(kxp0bf[p][0]-pi/a0)+cos(180*rad)*kyp0bf[p][0]	kxppaf[][0]=abs(kxppa[p])	kyppaf[][0]=abs(kyppa[p])	kxppaf[][1]=cos(180*rad)*(kxppaf[p][0]-pi/a0)-sin(180*rad)*(kyppaf[p][0]-pi/b0)+pi/a0	kyppaf[][1]=sin(180*rad)*(kxppaf[p][0]-pi/a0)+cos(180*rad)*(kyppaf[p][0]-pi/b0)+pi/b0	kxppbf[][0]=abs(kxppb[p])	kyppbf[][0]=abs(kyppb[p])	kxppbf[][1]=cos(180*rad)*(kxppbf[p][0]-pi/a0)-sin(180*rad)*(kyppbf[p][0]-pi/b0)+pi/a0	kyppbf[][1]=sin(180*rad)*(kxppbf[p][0]-pi/a0)+cos(180*rad)*(kyppbf[p][0]-pi/b0)+pi/b0		kx00af[][4]=kx00af[p][0]					//kF00とkFp0をky=0に対して鏡面対称操作　(kx'=kx,  ky'=-ky)	kx00af[][5]=kx00af[p][1]	kx00af[][6]=kx00af[p][2]	kx00af[][7]=kx00af[p][3]	ky00af[][4]=-ky00af[p][0]	ky00af[][5]=-ky00af[p][1]	ky00af[][6]=-ky00af[p][2]	ky00af[][7]=-ky00af[p][3]	kx00bf[][4]=kx00bf[p][0]	kx00bf[][5]=kx00bf[p][1]	kx00bf[][6]=kx00bf[p][2]	kx00bf[][7]=kx00bf[p][3]	ky00bf[][4]=-ky00bf[p][0]	ky00bf[][5]=-ky00bf[p][1]	ky00bf[][6]=-ky00bf[p][2]	ky00bf[][7]=-ky00bf[p][3]	kxp0af[][2]=kxp0af[p][0]	kxp0af[][3]=kxp0af[p][1]	kyp0af[][2]=-kyp0af[p][0]	kyp0af[][3]=-kyp0af[p][1]	kxp0bf[][2]=kxp0bf[p][0]	kxp0bf[][3]=kxp0bf[p][1]	kyp0bf[][2]=-kyp0bf[p][0]	kyp0bf[][3]=-kyp0bf[p][1]	kxppaf[][2]=-(kxppaf[p][0]-pi/a0)+pi/a0					//kFppをky=kxに対して鏡面対称操作	kxppaf[][3]=-(kxppaf[p][1]-pi/a0)+pi/a0	kyppaf[][2]=-(kyppaf[p][0]-pi/b0)+pi/b0	kyppaf[][3]=-(kyppaf[p][1]-pi/b0)+pi/b0	kxppbf[][2]=-(kxppbf[p][0]-pi/a0)+pi/a0	kxppbf[][3]=-(kxppbf[p][1]-pi/a0)+pi/a0	kyppbf[][2]=-(kyppbf[p][0]-pi/b0)+pi/b0	kyppbf[][3]=-(kyppbf[p][1]-pi/b0)+pi/b0	kxp0af[][4]=cos(90*rad)*kxp0af[p][0]-sin(90*rad)*kyp0af[p][0]		//(±pi,0)と(±pi,±pi)のkFを(0,0)を中心として90度×4回回転	kyp0af[][4]=sin(90*rad)*kxp0af[p][0]+cos(90*rad)*kyp0af[p][0]	kxp0af[][5]=cos(90*rad)*kxp0af[p][1]-sin(90*rad)*kyp0af[p][1]	kyp0af[][5]=sin(90*rad)*kxp0af[p][1]+cos(90*rad)*kyp0af[p][1]	kxp0af[][6]=cos(90*rad)*kxp0af[p][2]-sin(90*rad)*kyp0af[p][2]	kyp0af[][6]=sin(90*rad)*kxp0af[p][2]+cos(90*rad)*kyp0af[p][2]	kxp0af[][7]=cos(90*rad)*kxp0af[p][3]-sin(90*rad)*kyp0af[p][3]	kyp0af[][7]=sin(90*rad)*kxp0af[p][3]+cos(90*rad)*kyp0af[p][3]	kxp0af[][8]=cos(180*rad)*kxp0af[p][0]-sin(180*rad)*kyp0af[p][0]	kyp0af[][8]=sin(180*rad)*kxp0af[p][0]+cos(180*rad)*kyp0af[p][0]	kxp0af[][9]=cos(180*rad)*kxp0af[p][1]-sin(180*rad)*kyp0af[p][1]	kyp0af[][9]=sin(180*rad)*kxp0af[p][1]+cos(180*rad)*kyp0af[p][1]	kxp0af[][10]=cos(180*rad)*kxp0af[p][2]-sin(180*rad)*kyp0af[p][2]	kyp0af[][10]=sin(180*rad)*kxp0af[p][2]+cos(180*rad)*kyp0af[p][2]	kxp0af[][11]=cos(180*rad)*kxp0af[p][3]-sin(180*rad)*kyp0af[p][3]	kyp0af[][11]=sin(180*rad)*kxp0af[p][3]+cos(180*rad)*kyp0af[p][3]	kxp0af[][12]=cos(270*rad)*kxp0af[p][0]-sin(270*rad)*kyp0af[p][0]	kyp0af[][12]=sin(270*rad)*kxp0af[p][0]+cos(270*rad)*kyp0af[p][0]	kxp0af[][13]=cos(270*rad)*kxp0af[p][1]-sin(270*rad)*kyp0af[p][1]	kyp0af[][13]=sin(270*rad)*kxp0af[p][1]+cos(270*rad)*kyp0af[p][1]	kxp0af[][14]=cos(270*rad)*kxp0af[p][2]-sin(270*rad)*kyp0af[p][2]	kyp0af[][14]=sin(270*rad)*kxp0af[p][2]+cos(270*rad)*kyp0af[p][2]	kxp0af[][15]=cos(270*rad)*kxp0af[p][3]-sin(270*rad)*kyp0af[p][3]	kyp0af[][15]=sin(270*rad)*kxp0af[p][3]+cos(270*rad)*kyp0af[p][3]	kxp0bf[][4]=cos(90*rad)*kxp0bf[p][0]-sin(90*rad)*kyp0bf[p][0]	kyp0bf[][4]=sin(90*rad)*kxp0bf[p][0]+cos(90*rad)*kyp0bf[p][0]	kxp0bf[][5]=cos(90*rad)*kxp0bf[p][1]-sin(90*rad)*kyp0bf[p][1]	kyp0bf[][5]=sin(90*rad)*kxp0bf[p][1]+cos(90*rad)*kyp0bf[p][1]	kxp0bf[][6]=cos(90*rad)*kxp0bf[p][2]-sin(90*rad)*kyp0bf[p][2]	kyp0bf[][6]=sin(90*rad)*kxp0bf[p][2]+cos(90*rad)*kyp0bf[p][2]	kxp0bf[][7]=cos(90*rad)*kxp0bf[p][3]-sin(90*rad)*kyp0bf[p][3]	kyp0bf[][7]=sin(90*rad)*kxp0bf[p][3]+cos(90*rad)*kyp0bf[p][3]	kxp0bf[][8]=cos(180*rad)*kxp0bf[p][0]-sin(180*rad)*kyp0bf[p][0]	kyp0bf[][8]=sin(180*rad)*kxp0bf[p][0]+cos(180*rad)*kyp0bf[p][0]	kxp0bf[][9]=cos(180*rad)*kxp0bf[p][1]-sin(180*rad)*kyp0bf[p][1]	kyp0bf[][9]=sin(180*rad)*kxp0bf[p][1]+cos(180*rad)*kyp0bf[p][1]	kxp0bf[][10]=cos(180*rad)*kxp0bf[p][2]-sin(180*rad)*kyp0bf[p][2]	kyp0bf[][10]=sin(180*rad)*kxp0bf[p][2]+cos(180*rad)*kyp0bf[p][2]	kxp0bf[][11]=cos(180*rad)*kxp0bf[p][3]-sin(180*rad)*kyp0bf[p][3]	kyp0bf[][11]=sin(180*rad)*kxp0bf[p][3]+cos(180*rad)*kyp0bf[p][3]	kxp0bf[][12]=cos(270*rad)*kxp0bf[p][0]-sin(270*rad)*kyp0bf[p][0]	kyp0bf[][12]=sin(270*rad)*kxp0bf[p][0]+cos(270*rad)*kyp0bf[p][0]	kxp0bf[][13]=cos(270*rad)*kxp0bf[p][1]-sin(270*rad)*kyp0bf[p][1]	kyp0bf[][13]=sin(270*rad)*kxp0bf[p][1]+cos(270*rad)*kyp0bf[p][1]	kxp0bf[][14]=cos(270*rad)*kxp0bf[p][2]-sin(270*rad)*kyp0bf[p][2]	kyp0bf[][14]=sin(270*rad)*kxp0bf[p][2]+cos(270*rad)*kyp0bf[p][2]	kxp0bf[][15]=cos(270*rad)*kxp0bf[p][3]-sin(270*rad)*kyp0bf[p][3]	kyp0bf[][15]=sin(270*rad)*kxp0bf[p][3]+cos(270*rad)*kyp0bf[p][3]		kxppaf[][4]=cos(90*rad)*kxppaf[p][0]-sin(90*rad)*kyppaf[p][0]		kyppaf[][4]=sin(90*rad)*kxppaf[p][0]+cos(90*rad)*kyppaf[p][0]	kxppaf[][5]=cos(90*rad)*kxppaf[p][1]-sin(90*rad)*kyppaf[p][1]	kyppaf[][5]=sin(90*rad)*kxppaf[p][1]+cos(90*rad)*kyppaf[p][1]	kxppaf[][6]=cos(90*rad)*kxppaf[p][2]-sin(90*rad)*kyppaf[p][2]	kyppaf[][6]=sin(90*rad)*kxppaf[p][2]+cos(90*rad)*kyppaf[p][2]	kxppaf[][7]=cos(90*rad)*kxppaf[p][3]-sin(90*rad)*kyppaf[p][3]	kyppaf[][7]=sin(90*rad)*kxppaf[p][3]+cos(90*rad)*kyppaf[p][3]	kxppaf[][8]=cos(180*rad)*kxppaf[p][0]-sin(180*rad)*kyppaf[p][0]		kyppaf[][8]=sin(180*rad)*kxppaf[p][0]+cos(180*rad)*kyppaf[p][0]	kxppaf[][9]=cos(180*rad)*kxppaf[p][1]-sin(180*rad)*kyppaf[p][1]	kyppaf[][9]=sin(180*rad)*kxppaf[p][1]+cos(180*rad)*kyppaf[p][1]	kxppaf[][10]=cos(180*rad)*kxppaf[p][2]-sin(180*rad)*kyppaf[p][2]	kyppaf[][10]=sin(180*rad)*kxppaf[p][2]+cos(180*rad)*kyppaf[p][2]	kxppaf[][11]=cos(180*rad)*kxppaf[p][3]-sin(180*rad)*kyppaf[p][3]	kyppaf[][11]=sin(180*rad)*kxppaf[p][3]+cos(180*rad)*kyppaf[p][3]	kxppaf[][12]=cos(270*rad)*kxppaf[p][0]-sin(270*rad)*kyppaf[p][0]		kyppaf[][12]=sin(270*rad)*kxppaf[p][0]+cos(270*rad)*kyppaf[p][0]	kxppaf[][13]=cos(270*rad)*kxppaf[p][1]-sin(270*rad)*kyppaf[p][1]	kyppaf[][13]=sin(270*rad)*kxppaf[p][1]+cos(270*rad)*kyppaf[p][1]	kxppaf[][14]=cos(270*rad)*kxppaf[p][2]-sin(270*rad)*kyppaf[p][2]	kyppaf[][14]=sin(270*rad)*kxppaf[p][2]+cos(270*rad)*kyppaf[p][2]	kxppaf[][15]=cos(270*rad)*kxppaf[p][3]-sin(270*rad)*kyppaf[p][3]	kyppaf[][15]=sin(270*rad)*kxppaf[p][3]+cos(270*rad)*kyppaf[p][3]		kxppbf[][4]=cos(90*rad)*kxppbf[p][0]-sin(90*rad)*kyppbf[p][0]		kyppbf[][4]=sin(90*rad)*kxppbf[p][0]+cos(90*rad)*kyppbf[p][0]	kxppbf[][5]=cos(90*rad)*kxppbf[p][1]-sin(90*rad)*kyppbf[p][1]	kyppbf[][5]=sin(90*rad)*kxppbf[p][1]+cos(90*rad)*kyppbf[p][1]	kxppbf[][6]=cos(90*rad)*kxppbf[p][2]-sin(90*rad)*kyppbf[p][2]	kyppbf[][6]=sin(90*rad)*kxppbf[p][2]+cos(90*rad)*kyppbf[p][2]	kxppbf[][7]=cos(90*rad)*kxppbf[p][3]-sin(90*rad)*kyppbf[p][3]	kyppbf[][7]=sin(90*rad)*kxppbf[p][3]+cos(90*rad)*kyppbf[p][3]	kxppbf[][8]=cos(180*rad)*kxppbf[p][0]-sin(180*rad)*kyppbf[p][0]		kyppbf[][8]=sin(180*rad)*kxppbf[p][0]+cos(180*rad)*kyppbf[p][0]	kxppbf[][9]=cos(180*rad)*kxppbf[p][1]-sin(180*rad)*kyppbf[p][1]	kyppbf[][9]=sin(180*rad)*kxppbf[p][1]+cos(180*rad)*kyppbf[p][1]	kxppbf[][10]=cos(180*rad)*kxppbf[p][2]-sin(180*rad)*kyppbf[p][2]	kyppbf[][10]=sin(180*rad)*kxppbf[p][2]+cos(180*rad)*kyppbf[p][2]	kxppbf[][11]=cos(180*rad)*kxppbf[p][3]-sin(180*rad)*kyppbf[p][3]	kyppbf[][11]=sin(180*rad)*kxppbf[p][3]+cos(180*rad)*kyppbf[p][3]	kxppbf[][12]=cos(270*rad)*kxppbf[p][0]-sin(270*rad)*kyppbf[p][0]		kyppbf[][12]=sin(270*rad)*kxppbf[p][0]+cos(270*rad)*kyppbf[p][0]	kxppbf[][13]=cos(270*rad)*kxppbf[p][1]-sin(270*rad)*kyppbf[p][1]	kyppbf[][13]=sin(270*rad)*kxppbf[p][1]+cos(270*rad)*kyppbf[p][1]	kxppbf[][14]=cos(270*rad)*kxppbf[p][2]-sin(270*rad)*kyppbf[p][2]	kyppbf[][14]=sin(270*rad)*kxppbf[p][2]+cos(270*rad)*kyppbf[p][2]	kxppbf[][15]=cos(270*rad)*kxppbf[p][3]-sin(270*rad)*kyppbf[p][3]	kyppbf[][15]=sin(270*rad)*kxppbf[p][3]+cos(270*rad)*kyppbf[p][3]If(FS_kunit==2)	kx00a/=pi/a0	ky00a/=pi/b0	kx00b/=pi/a0	ky00b/=pi/b0	kxp0a/=pi/a0	kyp0a/=pi/b0	kxp0b/=pi/a0	kyp0b/=pi/b0	kxppa/=pi/a0	kyppa/=pi/b0	kxppb/=pi/a0	kyppb/=pi/b0		kx00af/=pi/a0	ky00af/=pi/b0	kx00bf/=pi/a0	ky00bf/=pi/b0	kxp0af/=pi/a0	kyp0af/=pi/b0	kxp0bf/=pi/a0	kyp0bf/=pi/b0	kxppaf/=pi/a0	kyppaf/=pi/b0	kxppbf/=pi/a0	kyppbf/=pi/b0endifEnd MacroMacro  FS_kFkxky_perp()		//FS_kFkxkyの perpendicular mode用、 p0は0pを意味するvariable rad=pi/180variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angleaccept=FSmap_coef[3]variable thetaoffset=FSmap_coef[5]variable tiltoffset=FSmap_coef[7]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]pauseupdate; silent 1	variable length			length=dimsize(theta,0)	redimension/N=(length,0) FS00a	redimension/N=(length,0) FS00b	redimension/N=(length,0) FSp0a	redimension/N=(length,0) FSp0b	redimension/N=(length,0) FSppa	redimension/N=(length,0) FSppb	duplicate/O FS00a delta	duplicate/O FS00a kFx	duplicate/O FS00a kFy	duplicate/O FS00a kx00a	duplicate/O FS00a ky00a	duplicate/O FS00a kx00b	duplicate/O FS00a ky00b	duplicate/O FS00a kxp0a	duplicate/O FS00a kyp0a	duplicate/O FS00a kxp0b	duplicate/O FS00a kyp0b	duplicate/O FS00a kxppa	duplicate/O FS00a kyppa	duplicate/O FS00a kxppb	duplicate/O FS00a kyppb		duplicate/O FS00a kx00af	duplicate/O FS00a ky00af	duplicate/O FS00a kx00bf	duplicate/O FS00a ky00bf	duplicate/O FS00a kxp0af	duplicate/O FS00a kyp0af	duplicate/O FS00a kxp0bf	duplicate/O FS00a kyp0bf	duplicate/O FS00a kxppaf	duplicate/O FS00a kyppaf	duplicate/O FS00a kxppbf	duplicate/O FS00a kyppbf		redimension/N=(length,8) kx00af	redimension/N=(length,8) ky00af	redimension/N=(length,8) kx00bf	redimension/N=(length,8) ky00bf	redimension/N=(length,16) kxp0af	redimension/N=(length,16) kyp0af	redimension/N=(length,16) kxp0bf	redimension/N=(length,16) kyp0bf	redimension/N=(length,16) kxppaf	redimension/N=(length,16) kyppaf	redimension/N=(length,16) kxppbf	redimension/N=(length,16) kyppbf		kx00af=nan	ky00af=nan	kx00bf=nan	ky00bf=nan	kxp0af=nan	kyp0af=nan	kxp0bf=nan	kyp0bf=nan	kxppaf=nan	kyppaf=nan	kxppbf=nan	kyppbf=nan			delta=angleaccept*(-0.5+FS00a/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	ky00a=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kx00a=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FS00b/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	ky00b=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kx00b=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSp0a/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	kyp0a=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxp0a=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSp0b/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	kyp0b=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxp0b=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSppa/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	kyppa=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxppa=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx		delta=angleaccept*(-0.5+FSppb/(slicenum-1))	kFy[]=sqrt(Ek/3.81283)*(sin((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta-thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//kyの計算	kFx[]=-sqrt(Ek/3.81283)*(cos((theta-thetaoffset)*rad)*sin(delta*rad)-sin((theta-thetaoffset)*rad)*cos(delta*rad))															//kxの計算	kyppb=cos((azimuth+azimuthoffset)*rad)*kFy+sin((azimuth+azimuthoffset)*rad)*kFx	kxppb=sin((azimuth+azimuthoffset)*rad)*kFy-cos((azimuth+azimuthoffset)*rad)*kFx	kx00af[][0]=abs(kx00a[p])			//kFを(0,0), (±pi,0), (±pi,±pi)を中心に回転、(0,0)は90度×4回、(±pi,0)と(±pi,±pi)は180度×2回	ky00af[][0]=abs(ky00a[p])	kx00af[][1]=cos(90*rad)*kx00af[p][0]-sin(90*rad)*ky00af[p][0]	ky00af[][1]=sin(90*rad)*kx00af[p][0]+cos(90*rad)*ky00af[p][0]	kx00af[][2]=cos(180*rad)*kx00af[p][0]-sin(180*rad)*ky00af[p][0]	ky00af[][2]=sin(180*rad)*kx00af[p][0]+cos(180*rad)*ky00af[p][0]	kx00af[][3]=cos(270*rad)*kx00af[p][0]-sin(270*rad)*ky00af[p][0]	ky00af[][3]=sin(270*rad)*kx00af[p][0]+cos(270*rad)*ky00af[p][0]	kx00bf[][0]=abs(kx00b[p])	ky00bf[][0]=abs(ky00b[p])	kx00bf[][1]=cos(90*rad)*kx00bf[p][0]-sin(90*rad)*ky00bf[p][0]	ky00bf[][1]=sin(90*rad)*kx00bf[p][0]+cos(90*rad)*ky00bf[p][0]	kx00bf[][2]=cos(180*rad)*kx00bf[p][0]-sin(180*rad)*ky00bf[p][0]	ky00bf[][2]=sin(180*rad)*kx00bf[p][0]+cos(180*rad)*ky00bf[p][0]	kx00bf[][3]=cos(270*rad)*kx00bf[p][0]-sin(270*rad)*ky00bf[p][0]	ky00bf[][3]=sin(270*rad)*kx00bf[p][0]+cos(270*rad)*ky00bf[p][0]	kxp0af[][0]=abs(kxp0a[p])	kyp0af[][0]=abs(kyp0a[p])	kxp0af[][1]=cos(180*rad)*kxp0af[p][0]-sin(180*rad)*(kyp0af[p][0]-pi/b0)	kyp0af[][1]=sin(180*rad)*kxp0af[p][0]+cos(180*rad)*(kyp0af[p][0]-pi/b0)+pi/b0	kxp0bf[][0]=abs(kxp0b[p])	kyp0bf[][0]=abs(kyp0b[p])	kxp0bf[][1]=cos(180*rad)*kxp0bf[p][0]-sin(180*rad)*(kyp0bf[p][0]-pi/b0)	kyp0bf[][1]=sin(180*rad)*kxp0bf[p][0]+cos(180*rad)*(kyp0bf[p][0]-pi/b0)+pi/b0	kxppaf[][0]=abs(kxppa[p])	kyppaf[][0]=abs(kyppa[p])	kxppaf[][1]=cos(180*rad)*(kxppaf[p][0]-pi/a0)-sin(180*rad)*(kyppaf[p][0]-pi/b0)+pi/a0	kyppaf[][1]=sin(180*rad)*(kxppaf[p][0]-pi/a0)+cos(180*rad)*(kyppaf[p][0]-pi/b0)+pi/b0	kxppbf[][0]=abs(kxppb[p])	kyppbf[][0]=abs(kyppb[p])	kxppbf[][1]=cos(180*rad)*(kxppbf[p][0]-pi/a0)-sin(180*rad)*(kyppbf[p][0]-pi/b0)+pi/a0	kyppbf[][1]=sin(180*rad)*(kxppbf[p][0]-pi/a0)+cos(180*rad)*(kyppbf[p][0]-pi/b0)+pi/b0		kx00af[][4]=-kx00af[p][0]					//kF00とkFp0をkx=0に対して鏡面対称操作　(kx'=-kx,  ky'=ky)	kx00af[][5]=-kx00af[p][1]	kx00af[][6]=-kx00af[p][2]	kx00af[][7]=-kx00af[p][3]	ky00af[][4]=ky00af[p][0]	ky00af[][5]=ky00af[p][1]	ky00af[][6]=ky00af[p][2]	ky00af[][7]=ky00af[p][3]	kx00bf[][4]=-kx00bf[p][0]	kx00bf[][5]=-kx00bf[p][1]	kx00bf[][6]=-kx00bf[p][2]	kx00bf[][7]=-kx00bf[p][3]	ky00bf[][4]=ky00bf[p][0]	ky00bf[][5]=ky00bf[p][1]	ky00bf[][6]=ky00bf[p][2]	ky00bf[][7]=ky00bf[p][3]	kxp0af[][2]=-kxp0af[p][0]	kxp0af[][3]=-kxp0af[p][1]	kyp0af[][2]=kyp0af[p][0]	kyp0af[][3]=kyp0af[p][1]	kxp0bf[][2]=-kxp0bf[p][0]	kxp0bf[][3]=-kxp0bf[p][1]	kyp0bf[][2]=kyp0bf[p][0]	kyp0bf[][3]=kyp0bf[p][1]	kxppaf[][2]=-(kxppaf[p][0]-pi/a0)+pi/a0					//kFppをky=kxに対して鏡面対称操作	kxppaf[][3]=-(kxppaf[p][1]-pi/a0)+pi/a0	kyppaf[][2]=-(kyppaf[p][0]-pi/b0)+pi/b0	kyppaf[][3]=-(kyppaf[p][1]-pi/b0)+pi/b0	kxppbf[][2]=-(kxppbf[p][0]-pi/a0)+pi/a0	kxppbf[][3]=-(kxppbf[p][1]-pi/a0)+pi/a0	kyppbf[][2]=-(kyppbf[p][0]-pi/b0)+pi/b0	kyppbf[][3]=-(kyppbf[p][1]-pi/b0)+pi/b0	kxp0af[][4]=cos(90*rad)*kxp0af[p][0]-sin(90*rad)*kyp0af[p][0]		//(±pi,0)と(±pi,±pi)のkFを(0,0)を中心として90度×4回回転	kyp0af[][4]=sin(90*rad)*kxp0af[p][0]+cos(90*rad)*kyp0af[p][0]	kxp0af[][5]=cos(90*rad)*kxp0af[p][1]-sin(90*rad)*kyp0af[p][1]	kyp0af[][5]=sin(90*rad)*kxp0af[p][1]+cos(90*rad)*kyp0af[p][1]	kxp0af[][6]=cos(90*rad)*kxp0af[p][2]-sin(90*rad)*kyp0af[p][2]	kyp0af[][6]=sin(90*rad)*kxp0af[p][2]+cos(90*rad)*kyp0af[p][2]	kxp0af[][7]=cos(90*rad)*kxp0af[p][3]-sin(90*rad)*kyp0af[p][3]	kyp0af[][7]=sin(90*rad)*kxp0af[p][3]+cos(90*rad)*kyp0af[p][3]	kxp0af[][8]=cos(180*rad)*kxp0af[p][0]-sin(180*rad)*kyp0af[p][0]	kyp0af[][8]=sin(180*rad)*kxp0af[p][0]+cos(180*rad)*kyp0af[p][0]	kxp0af[][9]=cos(180*rad)*kxp0af[p][1]-sin(180*rad)*kyp0af[p][1]	kyp0af[][9]=sin(180*rad)*kxp0af[p][1]+cos(180*rad)*kyp0af[p][1]	kxp0af[][10]=cos(180*rad)*kxp0af[p][2]-sin(180*rad)*kyp0af[p][2]	kyp0af[][10]=sin(180*rad)*kxp0af[p][2]+cos(180*rad)*kyp0af[p][2]	kxp0af[][11]=cos(180*rad)*kxp0af[p][3]-sin(180*rad)*kyp0af[p][3]	kyp0af[][11]=sin(180*rad)*kxp0af[p][3]+cos(180*rad)*kyp0af[p][3]	kxp0af[][12]=cos(270*rad)*kxp0af[p][0]-sin(270*rad)*kyp0af[p][0]	kyp0af[][12]=sin(270*rad)*kxp0af[p][0]+cos(270*rad)*kyp0af[p][0]	kxp0af[][13]=cos(270*rad)*kxp0af[p][1]-sin(270*rad)*kyp0af[p][1]	kyp0af[][13]=sin(270*rad)*kxp0af[p][1]+cos(270*rad)*kyp0af[p][1]	kxp0af[][14]=cos(270*rad)*kxp0af[p][2]-sin(270*rad)*kyp0af[p][2]	kyp0af[][14]=sin(270*rad)*kxp0af[p][2]+cos(270*rad)*kyp0af[p][2]	kxp0af[][15]=cos(270*rad)*kxp0af[p][3]-sin(270*rad)*kyp0af[p][3]	kyp0af[][15]=sin(270*rad)*kxp0af[p][3]+cos(270*rad)*kyp0af[p][3]	kxp0bf[][4]=cos(90*rad)*kxp0bf[p][0]-sin(90*rad)*kyp0bf[p][0]	kyp0bf[][4]=sin(90*rad)*kxp0bf[p][0]+cos(90*rad)*kyp0bf[p][0]	kxp0bf[][5]=cos(90*rad)*kxp0bf[p][1]-sin(90*rad)*kyp0bf[p][1]	kyp0bf[][5]=sin(90*rad)*kxp0bf[p][1]+cos(90*rad)*kyp0bf[p][1]	kxp0bf[][6]=cos(90*rad)*kxp0bf[p][2]-sin(90*rad)*kyp0bf[p][2]	kyp0bf[][6]=sin(90*rad)*kxp0bf[p][2]+cos(90*rad)*kyp0bf[p][2]	kxp0bf[][7]=cos(90*rad)*kxp0bf[p][3]-sin(90*rad)*kyp0bf[p][3]	kyp0bf[][7]=sin(90*rad)*kxp0bf[p][3]+cos(90*rad)*kyp0bf[p][3]	kxp0bf[][8]=cos(180*rad)*kxp0bf[p][0]-sin(180*rad)*kyp0bf[p][0]	kyp0bf[][8]=sin(180*rad)*kxp0bf[p][0]+cos(180*rad)*kyp0bf[p][0]	kxp0bf[][9]=cos(180*rad)*kxp0bf[p][1]-sin(180*rad)*kyp0bf[p][1]	kyp0bf[][9]=sin(180*rad)*kxp0bf[p][1]+cos(180*rad)*kyp0bf[p][1]	kxp0bf[][10]=cos(180*rad)*kxp0bf[p][2]-sin(180*rad)*kyp0bf[p][2]	kyp0bf[][10]=sin(180*rad)*kxp0bf[p][2]+cos(180*rad)*kyp0bf[p][2]	kxp0bf[][11]=cos(180*rad)*kxp0bf[p][3]-sin(180*rad)*kyp0bf[p][3]	kyp0bf[][11]=sin(180*rad)*kxp0bf[p][3]+cos(180*rad)*kyp0bf[p][3]	kxp0bf[][12]=cos(270*rad)*kxp0bf[p][0]-sin(270*rad)*kyp0bf[p][0]	kyp0bf[][12]=sin(270*rad)*kxp0bf[p][0]+cos(270*rad)*kyp0bf[p][0]	kxp0bf[][13]=cos(270*rad)*kxp0bf[p][1]-sin(270*rad)*kyp0bf[p][1]	kyp0bf[][13]=sin(270*rad)*kxp0bf[p][1]+cos(270*rad)*kyp0bf[p][1]	kxp0bf[][14]=cos(270*rad)*kxp0bf[p][2]-sin(270*rad)*kyp0bf[p][2]	kyp0bf[][14]=sin(270*rad)*kxp0bf[p][2]+cos(270*rad)*kyp0bf[p][2]	kxp0bf[][15]=cos(270*rad)*kxp0bf[p][3]-sin(270*rad)*kyp0bf[p][3]	kyp0bf[][15]=sin(270*rad)*kxp0bf[p][3]+cos(270*rad)*kyp0bf[p][3]		kxppaf[][4]=cos(90*rad)*kxppaf[p][0]-sin(90*rad)*kyppaf[p][0]		kyppaf[][4]=sin(90*rad)*kxppaf[p][0]+cos(90*rad)*kyppaf[p][0]	kxppaf[][5]=cos(90*rad)*kxppaf[p][1]-sin(90*rad)*kyppaf[p][1]	kyppaf[][5]=sin(90*rad)*kxppaf[p][1]+cos(90*rad)*kyppaf[p][1]	kxppaf[][6]=cos(90*rad)*kxppaf[p][2]-sin(90*rad)*kyppaf[p][2]	kyppaf[][6]=sin(90*rad)*kxppaf[p][2]+cos(90*rad)*kyppaf[p][2]	kxppaf[][7]=cos(90*rad)*kxppaf[p][3]-sin(90*rad)*kyppaf[p][3]	kyppaf[][7]=sin(90*rad)*kxppaf[p][3]+cos(90*rad)*kyppaf[p][3]	kxppaf[][8]=cos(180*rad)*kxppaf[p][0]-sin(180*rad)*kyppaf[p][0]		kyppaf[][8]=sin(180*rad)*kxppaf[p][0]+cos(180*rad)*kyppaf[p][0]	kxppaf[][9]=cos(180*rad)*kxppaf[p][1]-sin(180*rad)*kyppaf[p][1]	kyppaf[][9]=sin(180*rad)*kxppaf[p][1]+cos(180*rad)*kyppaf[p][1]	kxppaf[][10]=cos(180*rad)*kxppaf[p][2]-sin(180*rad)*kyppaf[p][2]	kyppaf[][10]=sin(180*rad)*kxppaf[p][2]+cos(180*rad)*kyppaf[p][2]	kxppaf[][11]=cos(180*rad)*kxppaf[p][3]-sin(180*rad)*kyppaf[p][3]	kyppaf[][11]=sin(180*rad)*kxppaf[p][3]+cos(180*rad)*kyppaf[p][3]	kxppaf[][12]=cos(270*rad)*kxppaf[p][0]-sin(270*rad)*kyppaf[p][0]		kyppaf[][12]=sin(270*rad)*kxppaf[p][0]+cos(270*rad)*kyppaf[p][0]	kxppaf[][13]=cos(270*rad)*kxppaf[p][1]-sin(270*rad)*kyppaf[p][1]	kyppaf[][13]=sin(270*rad)*kxppaf[p][1]+cos(270*rad)*kyppaf[p][1]	kxppaf[][14]=cos(270*rad)*kxppaf[p][2]-sin(270*rad)*kyppaf[p][2]	kyppaf[][14]=sin(270*rad)*kxppaf[p][2]+cos(270*rad)*kyppaf[p][2]	kxppaf[][15]=cos(270*rad)*kxppaf[p][3]-sin(270*rad)*kyppaf[p][3]	kyppaf[][15]=sin(270*rad)*kxppaf[p][3]+cos(270*rad)*kyppaf[p][3]		kxppbf[][4]=cos(90*rad)*kxppbf[p][0]-sin(90*rad)*kyppbf[p][0]		kyppbf[][4]=sin(90*rad)*kxppbf[p][0]+cos(90*rad)*kyppbf[p][0]	kxppbf[][5]=cos(90*rad)*kxppbf[p][1]-sin(90*rad)*kyppbf[p][1]	kyppbf[][5]=sin(90*rad)*kxppbf[p][1]+cos(90*rad)*kyppbf[p][1]	kxppbf[][6]=cos(90*rad)*kxppbf[p][2]-sin(90*rad)*kyppbf[p][2]	kyppbf[][6]=sin(90*rad)*kxppbf[p][2]+cos(90*rad)*kyppbf[p][2]	kxppbf[][7]=cos(90*rad)*kxppbf[p][3]-sin(90*rad)*kyppbf[p][3]	kyppbf[][7]=sin(90*rad)*kxppbf[p][3]+cos(90*rad)*kyppbf[p][3]	kxppbf[][8]=cos(180*rad)*kxppbf[p][0]-sin(180*rad)*kyppbf[p][0]		kyppbf[][8]=sin(180*rad)*kxppbf[p][0]+cos(180*rad)*kyppbf[p][0]	kxppbf[][9]=cos(180*rad)*kxppbf[p][1]-sin(180*rad)*kyppbf[p][1]	kyppbf[][9]=sin(180*rad)*kxppbf[p][1]+cos(180*rad)*kyppbf[p][1]	kxppbf[][10]=cos(180*rad)*kxppbf[p][2]-sin(180*rad)*kyppbf[p][2]	kyppbf[][10]=sin(180*rad)*kxppbf[p][2]+cos(180*rad)*kyppbf[p][2]	kxppbf[][11]=cos(180*rad)*kxppbf[p][3]-sin(180*rad)*kyppbf[p][3]	kyppbf[][11]=sin(180*rad)*kxppbf[p][3]+cos(180*rad)*kyppbf[p][3]	kxppbf[][12]=cos(270*rad)*kxppbf[p][0]-sin(270*rad)*kyppbf[p][0]		kyppbf[][12]=sin(270*rad)*kxppbf[p][0]+cos(270*rad)*kyppbf[p][0]	kxppbf[][13]=cos(270*rad)*kxppbf[p][1]-sin(270*rad)*kyppbf[p][1]	kyppbf[][13]=sin(270*rad)*kxppbf[p][1]+cos(270*rad)*kyppbf[p][1]	kxppbf[][14]=cos(270*rad)*kxppbf[p][2]-sin(270*rad)*kyppbf[p][2]	kyppbf[][14]=sin(270*rad)*kxppbf[p][2]+cos(270*rad)*kyppbf[p][2]	kxppbf[][15]=cos(270*rad)*kxppbf[p][3]-sin(270*rad)*kyppbf[p][3]	kyppbf[][15]=sin(270*rad)*kxppbf[p][3]+cos(270*rad)*kyppbf[p][3]If(FS_kunit==2)	kx00a/=pi/a0	ky00a/=pi/b0	kx00b/=pi/a0	ky00b/=pi/b0	kxp0a/=pi/a0	kyp0a/=pi/b0	kxp0b/=pi/a0	kyp0b/=pi/b0	kxppa/=pi/a0	kyppa/=pi/b0	kxppb/=pi/a0	kyppb/=pi/b0		kx00af/=pi/a0	ky00af/=pi/b0	kx00bf/=pi/a0	ky00bf/=pi/b0	kxp0af/=pi/a0	kyp0af/=pi/b0	kxp0bf/=pi/a0	kyp0bf/=pi/b0	kxppaf/=pi/a0	kyppaf/=pi/b0	kxppbf/=pi/a0	kyppbf/=pi/b0endifEnd Macromacro FS_appendkF()pauseupdate; silent 1append ky00a vs kx00aappend ky00b vs kx00bappend kyp0a vs kxp0aappend kyp0b vs kxp0bappend kyppa vs kxppaappend kyppb vs kxppbModifyGraph mode(ky00a)=3,marker(ky00a)=19,msize(ky00a)=2ModifyGraph rgb(ky00a)=(0,0,65535),mode(ky00b)=3,marker(ky00b)=19ModifyGraph msize(ky00b)=2,rgb(ky00b)=(0,0,65535),mode(kyp0a)=3ModifyGraph marker(kyp0a)=19,msize(kyp0a)=2,rgb(kyp0a)=(0,0,65535)ModifyGraph mode(kyp0b)=3,marker(kyp0b)=19,msize(kyp0b)=2ModifyGraph rgb(kyp0b)=(0,0,65535), mode(kyppa)=3,marker(kyppa)=19ModifyGraph msize(kyppa)=2,rgb(kyppa)=(0,0,65535),mode(kyppb)=3ModifyGraph marker(kyppb)=19,msize(kyppb)=2,rgb(kyppb)=(0,0,65535)endmacromacro FS_removekF()pauseupdate; silent 1RemoveFromGraph/Z ky00a, ky00b, kyp0a, kyp0b, kyppa, kyppbendmacromacro FS_appendkF4fold()pauseupdate; silent 1	append ky00af vs kx00af	append ky00bf vs kx00bf	append kyp0af vs kxp0af	append kyp0bf vs kxp0bf	append kyppaf vs kxppaf	append kyppbf vs kxppbf	ModifyGraph mode(ky00af)=3,marker(ky00af)=19,msize(ky00af)=2,mode(ky00bf)=3	ModifyGraph marker(ky00bf)=19,msize(ky00bf)=2,mode(kyp0af)=3,marker(kyp0af)=19	ModifyGraph msize(kyp0af)=2,mode(kyp0bf)=3,marker(kyp0bf)=19,msize(kyp0bf)=2	ModifyGraph mode(kyppaf)=3,marker(kyppaf)=19,msize(kyppaf)=2,mode(kyppbf)=3	ModifyGraph marker(kyppbf)=19,msize(kyppbf)=2Endmacromacro FS_removekF4fold()pauseupdate; silent 1	RemoveFromGraph/Z  ky00af, ky00bf, kyp0af, kyp0bf, kyppaf, kyppbfendmacroFunction ButtonProc_FS_FSmap_editkFtable(ctrlName) : ButtonControl	String ctrlName		execute "FS_edit_kFtable()"EndFunction ButtonProc_FS_FSmap_kFtable(ctrlName) : ButtonControl	String ctrlName		execute "FS_edit_kFtable()"EndFunction ButtonProc_FS_FSmap_appendkF(ctrlName) : ButtonControl	String ctrlName		execute "FS_appendkF()"EndFunction ButtonProc_FS_FSmap_removekF(ctrlName) : ButtonControl	String ctrlName		execute "FS_removekF()"EndFunction ButtonProc_FS_FSmap_appendkF2(ctrlName) : ButtonControl	String ctrlName	Execute "FS_appendkF4fold()"EndFunction ButtonProc_FS_FSmap_removekF2(ctrlName) : ButtonControl	String ctrlName	Execute "FS_removekF4fold()"EndFunction ButtonProc_FS_cuts_calcFSangle(ctrlName) : ButtonControl			//csr(B)を原点とした場合の、csr(A)におけるFSangleを計算	String ctrlName	wave FS_angle	wave cuts_coef		cuts_coef[14]=0.1*round(10*atan(-(vcsr(A)-vcsr(B))/(hcsr(A)-hcsr(B)))*180/pi)EndMacro FS_FSkxky_ContourZ(MatName,NewName,hmesh,vmesh)			//analyzer slitとmanipulatorが平行な場合String MatName="Image2DName"String NewName="Int_kxky"variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable thetaoffset=FSmap_coef[5]variable tilt=FSmap_coef[6]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]Variable vmesh=FSmap_coef[12]Variable Rws,Cols,delta,theta,totalRws=Dimsize($Matname,0)								//kxky2DマトリックスのRowsの設定Cols=Dimsize($Matname,1)								//kxky2DマトリックスのColumsの設定total=Rws*(Cols+1)			//kx (ky) waveの長さの指定Make/N=(total)/D/O kx0			//kx0のwaveの生成Make/N=(total)/D/O ky0			//ky0のwaveの生成Make/N=(total)/D/O kx			//kxのwaveの生成Make/N=(total)/D/O ky			//kyのwaveの生成Make/N=(total)/D/O TwoDint		//強度のwaveの生成variable i=0,j=0,k=0,radrad=pi/180Pauseupdate; silent 1		// kx, ky, 強度を計算Doi=0	Do	delta=-angaccept/2+i*angaccept/(slicenum-1)			//AR-modeにおける取り込み角度deltaの計算	theta=Dimoffset($Matname,0)+j*Dimdelta($Matname,0)				//Thetaの計算	ky0[k]=sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//ky0の計算	kx0[k]=-sqrt(Ek/3.81283)*sin((theta+thetaoffset)*rad)*cos(delta*rad)																			//kx0の計算	ky[k]=cos((azimuth+azimuthoffset)*rad)*ky0[k]+sin((azimuth+azimuthoffset)*rad)*kx0[k]	//kyの計算	kx[k]=sin((azimuth+azimuthoffset)*rad)*ky0[k]-cos((azimuth+azimuthoffset)*rad)*kx0[k]	//kxの計算																			TwoDint[k]=$Matname[j][i]		i+=1	k+=1	While (i<=Cols-1)	j+=1While (j<=Rws)If(FS_kunit==2)	kx/=pi/a0	ky/=pi/b0endifMake/N=(hmesh,vmesh)/D/O $NewName			//2Dkxkyマトリックス本体の生成	WaveStats/Q kx	SetScale/I x, V_min, V_max, "",$NewName		//2Dkxkyマトリックスのxwave lengthの設定	Variable Xmin,Xmax	Xmin=V_min;Xmax=V_max		WaveStats/Q ky											//2Dkxkyマトリックスのywave lengthの設定	SetScale/I y, V_min, V_max, "",$NewName	Variable Ymin,Ymax	Ymin=V_min;Ymax=V_max	Display;AppendXYZContour TwoDint vs {kx,ky}			//(kx,ky,強度)データをContour plotで表示DoWindow/C FScontourResumeupdate;Pauseupdate; silent 1$NewName=ContourZ("","",0,x,y)				//Contour plotを元にして、マトリクスを補間して計算dowindow/K FScontouri=0j=0Doi=0	Do		if ($NewName[i][j]==0)		$NewName[i][j]=NaN				//データ強度がゼロの部分をNaNに変換		Endif		i+=1	While  (i<=hmesh)j+=1While (j<=vmesh)//Display;AppendImage $NewName		//kxky2Dマトリックスを表示//ModifyImage $NewName ctab= {*,*,YellowHot,0}End MacroMacro FS_FSkxky_quick()String MatName="Image2DName"String NewName="Int_kxky"Variable  rad=pi/180variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable thetaoffset=FSmap_coef[5]variable tilt=FSmap_coef[6]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]Variable vmesh=FSmap_coef[12]FSmap_coef[13]=hmesh/Dimsize($matname,0)+0.5		//+0.5 は経験的にInt_kxkyに空白が現れない、かつ適度に小さい値FSmap_coef[14]=vmesh/Dimsize($matname,1)Variable  Interpfactorh=FSmap_coef[13]		//元データをinterpolateするときの指数	Interpolate後のデータ点は:  (元データのmesh数-1)*Interpfactor+1Variable  Interpfactorv=FSmap_coef[14]//Image2DNameが26*102の場合の mesh数 vs interpfactor//200*200	9*2//150*150	7*1.5//100*100	5*1//75*75		4*1//50*50		2.5*1Pauseupdate; silent 1//Smooth 3, MatName_smth	//元データをsmoothing//Imageinterpolate/f={(Interpfactorx),(Interpfactory)} /D=2 spline $MatName		//データをinterpolateImageinterpolate/f={(Interpfactorh),(Interpfactorv)} bilinear $MatName		//データをinterpolate, M_interpolatedImageという名前のmatrixが作成されるSetScale/I y (-angaccept/2),(angaccept/2),"", M_InterpolatedImage	//Interpolateした後のmatrixのx&y軸のscale設定SetScale/I x (Dimoffset($Matname,0)),(Dimoffset($Matname,0)+(Dimsize($Matname,0)-1)*Dimdelta($Matname,0)),"", M_InterpolatedImageduplicate/o M_InterpolatedImage kx0duplicate/o M_InterpolatedImage ky0duplicate/o M_InterpolatedImage kxduplicate/o M_InterpolatedImage kyky[][]=cos((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(y*rad)+cos((x+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(y*rad)))+sin((azimuth+azimuthoffset)*rad)*(-sqrt(Ek/3.81283)*sin((x+thetaoffset)*rad)*cos(y*rad))	//kyの計算kx[][]=sin((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(cos((tilt+tiltoffset)*rad)*sin(y*rad)+cos((x+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(y*rad)))-cos((azimuth+azimuthoffset)*rad)*(-sqrt(Ek/3.81283)*sin((x+thetaoffset)*rad)*cos(y*rad))	//kxの計算If(FS_kunit==2)ky/=pi/a0kx/=pi/b0endifMake/N=(hmesh,vmesh)/D/O $NewName			//Int_kxkyの生成$NewName=Nan	WaveStats/Q kx	SetScale/I x, V_min, V_max, "",$NewName		//Int_kxkyのx軸のscale設定	WaveStats/Q ky	SetScale/I y, V_min, V_max, "",$NewName		//Int_kxkyのy軸のscale設定kx0[][]=round( (kx[p][q]-Dimoffset($NewName,0))/Dimdelta($NewName,0) )ky0[][]=round( (ky[p][q]-Dimoffset($NewName,1))/Dimdelta($NewName,1) )Variable  Rows=Dimsize(M_InterpolatedImage,0)Variable  Cols=Dimsize(M_InterpolatedImage,1)Variable i=0Variable j=0FS_input(Rows, Cols, i, j, kx0, ky0, M_InterpolatedImage,$NewName)imagestats $NewName		//i強度を0-1に規格化$NewName-=V_minImagestats $NewName$NewName/=V_maxendfunction FS_input(Rows, Cols, i, j, kx0, ky0, Interpmat, FS)	wave kx0, ky0, Interpmat, FS	variable Rows, COls, i, j		Do		Do		FS[kx0[i][j]][ky0[i][j]]=Interpmat[i][j]		i+=1		while (i<Rows)	j+=1	i=0	While(j<Cols)endMacro FS_FSkxky_ContourZ_perp(MatName,NewName,hmesh,vmesh)	//analyzer slitとmanipulatorが垂直な場合String MatName="Image2DName"String NewName="Int_kxky"variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable theta=FSmap_coef[4]variable thetaoffset=FSmap_coef[5]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]Variable vmesh=FSmap_coef[12]Variable Rws,Cols,delta,tilt,totalRws=Dimsize($Matname,0)								//kxky2DマトリックスのRowsの設定Cols=Dimsize($Matname,1)								//kxky2DマトリックスのColumsの設定total=Rws*(Cols+1)			//kx (ky) waveの長さの指定Make/N=(total)/D/O kx0			//kx0のwaveの生成Make/N=(total)/D/O ky0			//ky0のwaveの生成Make/N=(total)/D/O kx			//kxのwaveの生成Make/N=(total)/D/O ky			//kyのwaveの生成Make/N=(total)/D/O TwoDint		//強度のwaveの生成variable i=0,j=0,k=0,radrad=pi/180Pauseupdate; silent 1		// kx, ky, 強度を計算Doi=0	Do	delta=-angaccept/2+i*angaccept/(slicenum-1)			//AR-modeにおける取り込み角度deltaの計算	delta*=-1												//Image2DNameとInt_kxkyを比較した際に、取り込み角方向の正負が対応するようにdeltaの符号を反対にする	tilt=Dimoffset($Matname,0)+j*Dimdelta($Matname,0)				//Thetaの計算	ky0[k]=sqrt(Ek/3.81283)*(sin((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*sin(delta*rad)+cos((theta+thetaoffset)*rad)*sin((tilt+tiltoffset)*rad)*cos(delta*rad))		//ky0の計算	kx0[k]=sqrt(Ek/3.81283)*(cos((theta+thetaoffset)*rad)*sin(delta*rad)-sin((theta+thetaoffset)*rad)*cos(delta*rad))	//ky0の計算	ky[k]=cos((azimuth+azimuthoffset)*rad)*ky0[k]+sin((azimuth+azimuthoffset)*rad)*kx0[k]	//kxの計算	kx[k]=sin((azimuth+azimuthoffset)*rad)*ky0[k]-cos((azimuth+azimuthoffset)*rad)*kx0[k]	//kyの計算																			TwoDint[k]=$Matname[j][i]		i+=1	k+=1	While (i<=Cols-1)	j+=1While (j<=Rws)If(FS_kunit==2)	kx/=pi/a0	ky/=pi/b0endifMake/N=(hmesh,vmesh)/D/O $NewName			//2Dkxkyマトリックス本体の生成	WaveStats/Q kx	SetScale/I x, V_min, V_max, "",$NewName		//2Dkxkyマトリックスのxwave lengthの設定	Variable Xmin,Xmax	Xmin=V_min;Xmax=V_max		WaveStats/Q ky											//2Dkxkyマトリックスのywave lengthの設定	SetScale/I y, V_min, V_max, "",$NewName	Variable Ymin,Ymax	Ymin=V_min;Ymax=V_max	Display;AppendXYZContour TwoDint vs {kx,ky}			//(kx,ky,強度)データをContour plotで表示DoWindow/C FScontourResumeupdate;Pauseupdate; silent 1$NewName=ContourZ("","",0,x,y)				//Contour plotを元にして、マトリクスを補間して計算dowindow/K FScontouri=0j=0Doi=0	Do		if ($NewName[i][j]==0)		$NewName[i][j]=NaN				//データ強度がゼロの部分をNaNに変換		Endif		i+=1	While  (i<=hmesh)j+=1While (j<=vmesh)End MacroMacro FS_FSkxky_quick_perp()String MatName="Image2DName"String NewName="Int_kxky"Variable  rad=pi/180variable ek=FSmap_coef[0]variable a0=FSmap_coef[1]variable b0=FSmap_coef[2]variable angaccept=FSmap_coef[3]variable theta=FSmap_coef[4]variable thetaoffset=FSmap_coef[5]variable tiltoffset=FSmap_coef[7]variable azimuth=FSmap_coef[8]variable azimuthoffset=FSmap_coef[9]variable slicenum=FSmap_coef[10]Variable hmesh=FSmap_coef[11]Variable vmesh=FSmap_coef[12]FSmap_coef[13]=hmesh/Dimsize($matname,0)+0.5		//+0.5 は経験的にInt_kxkyに空白が現れない、かつ適度に小さい値FSmap_coef[14]=vmesh/Dimsize($matname,1)+0.2Variable  Interpfactorh=FSmap_coef[13]		//元データをinterpolateするときの指数	Interpolate後のデータ点は:  (元データのmesh数-1)*Interpfactor+1Variable  Interpfactorv=FSmap_coef[14]//Image2DNameが26*102の場合の mesh数 vs interpfactor//200*200	9*2//150*150	7*1.5//100*100	5*1//75*75		4*1//50*50		2.5*1Pauseupdate; silent 1//Smooth 3, MatName_smth	//元データをsmoothing//Imageinterpolate/f={(Interpfactorx),(Interpfactory)} /D=2 spline $MatName		//データをinterpolateImageinterpolate/f={(Interpfactorh),(Interpfactorv)} bilinear $MatName		//データをinterpolate, M_interpolatedImageという名前のmatrixが作成されるSetScale/I y (angaccept/2),(-angaccept/2),"", M_InterpolatedImage	//Image2DNameとInt_kxky間で、正負が対応するようにdeltaの符号を反転してあるSetScale/I x (Dimoffset($Matname,0)),(Dimoffset($Matname,0)+(Dimsize($Matname,0)-1)*Dimdelta($Matname,0)),"", M_InterpolatedImageduplicate/o M_InterpolatedImage kx0duplicate/o M_InterpolatedImage ky0duplicate/o M_InterpolatedImage kxduplicate/o M_InterpolatedImage ky	//ky0=sqrt(Ek/3.81283)*(sin((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*sin(y*rad)+cos((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*cos(y*rad))		//ky0の計算	//kx0=sqrt(Ek/3.81283)*(cos((theta+thetaoffset)*rad)*sin(y*rad)-sin((theta+thetaoffset)*rad)*cos(y*rad))													//ky0の計算	//ky=cos((azimuth+azimuthoffset)*rad)*ky0+sin((azimuth+azimuthoffset)*rad)*kx0	//kxの計算	//kx=sin((azimuth+azimuthoffset)*rad)*ky0-cos((azimuth+azimuthoffset)*rad)*kx0	//kyの計算	ky=cos((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(sin((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*sin(y*rad)+cos((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*cos(y*rad)))+sin((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(cos((theta+thetaoffset)*rad)*sin(y*rad)-sin((theta+thetaoffset)*rad)*cos(y*rad)))	//kxの計算	kx=sin((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(sin((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*sin(y*rad)+cos((theta+thetaoffset)*rad)*sin((x+tiltoffset)*rad)*cos(y*rad)))-cos((azimuth+azimuthoffset)*rad)*(sqrt(Ek/3.81283)*(cos((theta+thetaoffset)*rad)*sin(y*rad)-sin((theta+thetaoffset)*rad)*cos(y*rad)))	//kyの計算If(FS_kunit==2)ky/=pi/a0kx/=pi/b0endifMake/N=(hmesh,vmesh)/D/O $NewName			//Int_kxkyの生成$NewName=Nan	WaveStats/Q kx	SetScale/I x, V_min, V_max, "",$NewName		//Int_kxkyのx軸のscale設定	WaveStats/Q ky	SetScale/I y, V_min, V_max, "",$NewName		//Int_kxkyのy軸のscale設定kx0[][]=round( (kx[p][q]-Dimoffset($NewName,0))/Dimdelta($NewName,0) )ky0[][]=round( (ky[p][q]-Dimoffset($NewName,1))/Dimdelta($NewName,1) )Variable  Rows=Dimsize(M_InterpolatedImage,0)Variable  Cols=Dimsize(M_InterpolatedImage,1)Variable i=0Variable j=0FS_input(Rows, Cols, i, j, kx0, ky0, M_InterpolatedImage,$NewName)imagestats $NewName		//i強度を0-1に規格化$NewName-=V_minImagestats $NewName$NewName/=V_maxendFunction TabProc_FS(ctrlName,tabNum) : TabControl	string ctrlName	variable tabNum		variable isTab0= tabNum==0	variable isTab1= tabNum==1		ModifyControl FS_FSmap_Ek disable= !isTab0	ModifyControl FS_FSmap_a disable= !isTab0	ModifyControl FS_FSmap_b disable= !isTab0	ModifyControl FS_FSmap_acceptanceangle disable= !isTab0	ModifyControl FS_FSmap_slicenum disable= !isTab0	ModifyControl FS_FSmap_theta disable= !isTab0	ModifyControl FS_FSmap_thetaoffset disable= !isTab0	ModifyControl FS_FSmap_tilt disable= !isTab0	ModifyControl FS_FSmap_tiltoffset disable= !isTab0	ModifyControl FS_FSmap_azimuth disable= !isTab0	ModifyControl FS_FSmap_azimuthoffset disable= !isTab0	ModifyControl FS_FSmap_para disable= !isTab0	ModifyControl FS_FSmap_kFtable disable= !isTab0	ModifyControl FS_FSmap_appendkF disable= !isTab0	ModifyControl FS_FSmap_removekF disable= !isTab0	ModifyControl FS_FSmap_appendkF2 disable= !isTab0	ModifyControl FS_FSmap_removekF2 disable= !isTab0	ModifyControl FS_FSmap_FSkxky disable= !isTab0	ModifyControl FS_FSmap_FSkxky2 disable= !isTab0	ModifyControl FS_FSmap_hmesh disable= !isTab0	ModifyControl FS_FSmap_vmesh disable= !isTab0	ModifyControl FS_FSmap_appendFS disable= !isTab0	ModifyControl FS_FSmap_removeFS disable= !isTab0	ModifyControl FS_FSmap_updateFS disable= !isTab0	ModifyControl FS_FSmap_duplicate disable= !isTab0		ModifyControl FS_cuts_Ek disable= !isTab1	ModifyControl FS_cuts_a disable= !isTab1	ModifyControl FS_cuts_b disable= !isTab1	ModifyControl FS_cuts_acceptanceangle disable= !isTab1	ModifyControl FS_cuts_theta disable= !isTab1	ModifyControl FS_cuts_thetaoffset disable= !isTab1	ModifyControl FS_cuts_tilt disable= !isTab1	ModifyControl FS_cuts_tiltoffset disable= !isTab1	ModifyControl FS_cuts_azimuth disable= !isTab1	ModifyControl FS_cuts_azimuthoffset disable= !isTab1	ModifyControl FS_cuts_start disable= !isTab1	ModifyControl FS_cuts_step disable= !isTab1	ModifyControl FS_cuts_cutnum disable= !isTab1	ModifyControl FS_cuts_append disable= !isTab1	ModifyControl FS_cuts_remove disable= !isTab1	ModifyControl FS_cuts_mode disable= !isTab1	ModifyControl FS_cuts_ReadPara disable= !isTab1	ModifyControl FS_cuts_editpara disable= !isTab1	ModifyControl FS_cuts_FSangle disable= !isTab1	ModifyControl FS_cuts_calcFSangle disable= !isTab1		return 0EndFunction CheckProc_FS_FSmap_update(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	variable/G FS_update		if (checked==0) 	FS_update=0	else	FS_update=1	EndifEndmacro FS_appendFS()string matrixname="int_kxky"Pauseupdate; silent 1RemoveImage blankAppendImage $matrixnameModifyImage $matrixname ctab= {*,*,Terrain,0}appendimage blankendmacromacro FS_removeFS()string matrixname="int_kxky"RemoveImage/Z $matrixnameendmacroFunction ButtonProc_FS_FSmap_appendFS(ctrlName) : ButtonControl	String ctrlName		execute "FS_appendFS()"EndFunction ButtonProc_FS_FSmap_removeFS(ctrlName) : ButtonControl	String ctrlName		execute "FS_removeFS()"Endmacro FS_duplicateFS(newmatrixname)string matrixname="Int_kxky"string newmatrixname="MatrixName"duplicate/O $matrixname $newmatrixnamePauseupdate; silent 1display;appendimage $newmatrixnameModifyImage $newmatrixname ctab= {*,*,Terrain,0}endFunction ButtonProc_FS_FSmap_duplicate(ctrlName) : ButtonControl	String ctrlName		execute "FS_duplicateFS()"EndFunction PopMenuProc_FS_ARPESmode(pa) : PopupMenuControl	STRUCT WMPopupAction &pa	Variable/G FS_ARPESmode		switch( pa.eventCode )		case 2: // mouse up			Variable popNum = pa.popNum			String popStr = pa.popStr			break	endswitch		FS_ARPESmode=popNum	EndFunction ButtonProc_FS_FSkxky(ctrlName) : ButtonControl	String ctrlName	variable/G FS_ARPESmode		If(FS_ARPESmode==1)	Execute "FS_FSkxky_quick()"	endif		If(FS_ARPESmode==2)	Execute "FS_FSkxky_quick_perp()"	endif	EndFunction ButtonProc_FS_FSmap_FSkxky2(ctrlName) : ButtonControl	String ctrlName	variable/G FS_ARPESmode	If(FS_ARPESmode==1)	Execute "FS_FSkxky_ContourZ()"	endif		If(FS_ARPESmode==2)	Execute "FS_FSkxky_ContourZ_perp()"	endifEndFunction SetVarProc_FS_cuts_ab(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G FS_cuts_mode	variable/G FS_ARPESmode		If(FS_cuts_mode==1&&FS_ARPESmode==1)	Execute "FS_cuts_theta()"	endif		If(FS_cuts_mode==2&&FS_ARPESmode==1)	Execute "FS_cuts_tilt()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==1)	Execute "FS_cuts_azimuth()"	endif		If(FS_cuts_mode==1&&FS_ARPESmode==2)	Execute "FS_cuts_theta_perp()"	endif		If(FS_cuts_mode==2&&FS_ARPESmode==2)	Execute "FS_cuts_tilt_perp()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==2)	Execute "FS_cuts_azimuth_perp()"	endif		Execute "FS_drawZB()"EndFunction SetVarProc_FS_cuts_cutnum(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	wave cuts_coef	variable/G FS_cuts_mode	variable/G FS_ARPESmode		Execute "FS_cuts_remove()"	cuts_coef[13]=cuts_coef[12]		If(FS_cuts_mode==1&&FS_ARPESmode==1)	Execute "FS_cuts_theta2()"	endif		If(FS_cuts_mode==2&&FS_ARPESmode==1)	Execute "FS_cuts_tilt2()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==1)	Execute "FS_cuts_azimuth2()"	endif		If(FS_cuts_mode==1&&FS_ARPESmode==2)	Execute "FS_cuts_theta2_perp()"	endif	If(FS_cuts_mode==2&&FS_ARPESmode==2)	Execute "FS_cuts_tilt2_perp()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==2)	Execute "FS_cuts_azimuth2_perp()"	endif	EndFunction SetVarProc_FS_cuts_Ek(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	wave cuts_coef	variable/G FS_cuts_mode	variable/G FS_ARPESmode		If(FS_cuts_mode==1&&FS_ARPESmode==1)	Execute "FS_cuts_theta()"	endif		If(FS_cuts_mode==2&&FS_ARPESmode==1)	Execute "FS_cuts_tilt()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==1)	Execute "FS_cuts_azimuth()"	endif		If(FS_cuts_mode==1&&FS_ARPESmode==2)	Execute "FS_cuts_theta_perp()"	endif		If(FS_cuts_mode==2&&FS_ARPESmode==2)	Execute "FS_cuts_tilt_perp()"	endif		If(FS_cuts_mode==3&&FS_ARPESmode==2)	Execute "FS_cuts_azimuth_perp()"	endif	EndFunction SetVarProc_FS_FSmap_ek(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G FS_update	variable/G FS_ARPESmode		If(FS_ARPESmode==1)	Execute "FS_kFkxky()"	endif		If(FS_ARPESmode==2)	Execute "FS_kFkxky_perp()"	endif		If(FS_update==1&&FS_ARPESmode==1)	Execute "FS_FSkxky_quick()"	endif		If(FS_update==1&&FS_ARPESmode==2)	Execute "FS_FSkxky_quick_perp()"	endifEndFunction SetVarProc_FS_FSmap_ab(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	variable/G FS_update	variable/G FS_ARPESmode		If(FS_ARPESmode==1)	Execute "FS_kFkxky()"	endif		If(FS_ARPESmode==2)	Execute "FS_kFkxky_perp()"	endif		If(FS_update==1&&FS_ARPESmode==1)	Execute "FS_FSkxky_quick()"	endif		If(FS_update==1&&FS_ARPESmode==2)	Execute "FS_FSkxky_quick_perp()"	endif	Execute "FS_drawZB()"	EndWindow FS_mapping_window() : Graph	variable/G  FS_BZmode=1	variable/G FS_kunit=1	variable/G FS_ARPESmode=1	variable/G FS_update=0	variable/G FS_cuts_mode=1		PauseUpdate; Silent 1		// building window...	Make/O/N=15 FSmap_coef	FSmap_coef[0]=16.824	//Ek	FSmap_coef[1]=2.85	//a0	FSmap_coef[2]=2.85	//b0	FSmap_coef[3]=13.44	//acceptance angle	FSmap_coef[4]=0		//theta	FSmap_coef[5]=-180	//theta offset	FSmap_coef[6]=0		//tilt	FSmap_coef[7]=0		//tilt offset	FSmap_coef[8]=0		//azimuth	FSmap_coef[9]=0		//azimuth offset	FSmap_coef[10]=102	//slice number	FSmap_coef[11]=100	//mesh numver (horizontal axis)	FSmap_coef[12]=100	//mesh number (vertical axis)	FSmap_coef[13]=1		//interpolation factor (horizontal axis)	FSmap_coef[14]=1		//interpolation afctor (vertical axis)		Make/O/N=15 cuts_coef	cuts_coef[0]=16.824	//Ek	cuts_coef[1]=2.85		//a0	cuts_coef[2]=2.85		//b0	cuts_coef[3]=13.44	//acceptance angle	cuts_coef[4]=0			//theta	cuts_coef[5]=0			//theta offset	cuts_coef[6]=0			//tilt	cuts_coef[7]=0			//tilt offset	cuts_coef[8]=0			//azimuth	cuts_coef[9]=0			//azimuth offset	cuts_coef[10]=180		//start angle	cuts_coef[11]=1		//step angle	cuts_coef[12]=1		//cut number	cuts_coef[13]=1		//cut number (temporary)	cuts_coef[14]=0		//FS angle				Make/O/N=(601,601)/D/O blank	SetScale/I x -3,3,"", blank	SetScale/I y -3,3,"", blank		Make/O/N=1 ZB,ZBx	FS_drawZB()	Make/O/N=1 theta,tilt,azimuth,FS00a,FS00b,FSp0a,FSp0b,FSppa,FSppb	FS00a=nan	FS00b=nan	FSp0a=nan	FSp0b=nan	FSppa=nan	FSppb=nan		Display /W=(339,44,755,516) ZB vs ZBx	AppendImage blank	ModifyGraph width={perUnit,141.732,bottom},height={perUnit,141.732,left}	ModifyGraph rgb=(34952,34952,34952)	ModifyGraph zero=2	ModifyGraph mirror=0	ModifyGraph standoff=0	SetAxis left -1,1.2	SetAxis bottom -1,1.2	ControlBar 100	TabControl tab0,pos={4,4},size={386,86},proc=TabProc_FS,tabLabel(0)="FSmap"	TabControl tab0,tabLabel(1)="cuts",value= 0	PopupMenu FS_BZmode,pos={5,3},size={73,17},proc=PopMenuProc_FS_BZMode	PopupMenu FS_BZmode font="Arial",fSize=8	PopupMenu FS_BZmode,mode=1,popvalue="TetraP0",value= #"\"TetraP0;TetraPP;HexM;HexK\""	PopupMenu FS_kunit,pos={81,3},size={50,17},proc=PopMenuProc_FS_kunit	PopupMenu FS_kunit font="Arial",fSize=8	PopupMenu FS_kunit,mode=1,popvalue="AA-1",value= #"\"AA-1;pi/a\""	PopupMenu FS_ARPESmode,pos={274,3},size={69,17},proc=PopMenuProc_FS_ARPESmode	PopupMenu FS_ARPESmode font="Arial",fSize=8	PopupMenu FS_ARPESmode,mode=1,popvalue="Parallel",value= #"\"Parallel;Perpendicular\""		//FSmap tab中のmenu	SetVariable FS_FSmap_Ek,pos={8,29},size={79,15},proc=SetVarProc_FS_FSmap_ek,title="Ek"	SetVariable FS_FSmap_Ek,limits={-inf,inf,0.001},value= FSmap_coef[0]	SetVariable FS_FSmap_a,pos={86,29},size={56,15},proc=SetVarProc_FS_FSmap_ab,title="a"	SetVariable FS_FSmap_a,limits={-inf,inf,0.01},value= FSmap_coef[1]	SetVariable FS_FSmap_b,pos={141,29},size={56,15},proc=SetVarProc_FS_FSmap_ab,title="b"	SetVariable FS_FSmap_b,limits={-inf,inf,0.01},value= FSmap_coef[2]	SetVariable FS_FSmap_acceptanceangle,pos={196,29},size={110,15},proc=SetVarProc_FS_FSmap_ek,title="ang.accept."	SetVariable FS_FSmap_acceptanceangle,limits={-inf,inf,0.01},value= FSmap_coef[3]	SetVariable FS_FSmap_slicenum,pos={305,29},size={56,15},proc=SetVarProc_FS_FSmap_ek,title="slices"	SetVariable FS_FSmap_slicenum,limits={-inf,inf,0},value= FSmap_coef[10]	Button FS_FSmap_para,pos={365,29},size={15,16},proc=ButtonProc_FS_FSmap_editpara,title="P"	Button FS_FSmap_para,fSize=9	SetVariable FS_FSmap_theta,pos={8,49},size={82,15},proc=SetVarProc_FS_FSmap_ek,title="theta"	SetVariable FS_FSmap_theta,fSize=9,value= FSmap_coef[4]	SetVariable FS_FSmap_thetaoffset,pos={89,49},size={55,15},proc=SetVarProc_FS_FSmap_ek,title=" "	SetVariable FS_FSmap_thetaoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_FSmap_thetaoffset,limits={-inf,inf,0.1},value= FSmap_coef[5]	SetVariable FS_FSmap_tilt,pos={143,49},size={71,15},proc=SetVarProc_FS_FSmap_ek,title="tilt"	SetVariable FS_FSmap_tilt,value= FSmap_coef[6]	SetVariable FS_FSmap_tiltoffset,pos={213,49},size={54,15},proc=SetVarProc_FS_FSmap_ek,title=" "	SetVariable FS_FSmap_tiltoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_FSmap_tiltoffset,limits={-inf,inf,0.1},value= FSmap_coef[7]	SetVariable FS_FSmap_azimuth,pos={266,49},size={72,15},proc=SetVarProc_FS_FSmap_ek,title="az."	SetVariable FS_FSmap_azimuth,value= FSmap_coef[8]	SetVariable FS_FSmap_azimuthoffset,pos={337,49},size={54,15},proc=SetVarProc_FS_FSmap_ek,title=" "	SetVariable FS_FSmap_azimuthoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_FSmap_azimuthoffset,limits={-inf,inf,0.1},value= FSmap_coef[9]	Button FS_FSmap_kFtable,pos={8,69},size={47,16},proc=ButtonProc_FS_FSmap_kFtable,title="kFtable"	Button FS_FSmap_kFtable,fSize=9,valueColor=(65535,0,0)	Button FS_FSmap_appendkF,pos={56,69},size={15,16},proc=ButtonProc_FS_FSmap_appendkF,title="a"	Button FS_FSmap_appendkF,fSize=9,valueColor=(65535,0,0)	Button FS_FSmap_removekF,pos={72,69},size={15,16},proc=ButtonProc_FS_FSmap_removekF,title="r"	Button FS_FSmap_removekF,fSize=9,valueColor=(65535,0,0)	Button FS_FSmap_appendkF2,pos={88,69},size={53,16},proc=ButtonProc_FS_FSmap_appendkF2,title="a(folded)"	Button FS_FSmap_appendkF2,fSize=9,fStyle=0,valueColor=(65535,0,52428)	Button FS_FSmap_removekF2,pos={142,69},size={15,16},proc=ButtonProc_FS_FSmap_removekF2,title="r"	Button FS_FSmap_removekF2,fSize=9,valueColor=(65535,0,52428)	Button FS_FSmap_FSkxky,pos={158,69},size={24,16},proc=ButtonProc_FS_FSkxky,title="FS"	Button FS_FSmap_FSkxky,fSize=9,valueColor=(0,0,65535)	Button FS_FSmap_FSkxky2,pos={183,69},size={30,16},proc=ButtonProc_FS_FSmap_FSkxky2,title="FS2"	Button FS_FSmap_FSkxky2,fSize=9,valueColor=(0,0,65535)	SetVariable FS_FSmap_hmesh,pos={216,69},size={38,15},title="h"	SetVariable FS_FSmap_hmesh,fColor=(0,0,65535)	SetVariable FS_FSmap_hmesh,limits={-inf,inf,0},value= FSmap_coef[11]	SetVariable FS_FSmap_vmesh,pos={257,69},size={38,15},title="v"	SetVariable FS_FSmap_vmesh,fColor=(0,0,65535)	SetVariable FS_FSmap_vmesh,limits={-inf,inf,0},value= FSmap_coef[12]	Button FS_FSmap_appendFS,pos={297,69},size={15,16},proc=ButtonProc_FS_FSmap_appendFS,title="a"	Button FS_FSmap_appendFS,fSize=9,valueColor=(0,0,65535)	Button FS_FSmap_removeFS,pos={313,69},size={15,16},proc=ButtonProc_FS_FSmap_removeFS,title="r"	Button FS_FSmap_removeFS,fSize=9,valueColor=(0,0,65535)	CheckBox FS_FSmap_updateFS,pos={331,70},size={20,14},proc=CheckProc_FS_FSmap_update,title=" "	CheckBox FS_FSmap_updateFS,value= 0	Button FS_FSmap_duplicate,pos={349,69},size={15,16},proc=ButtonProc_FS_FSmap_duplicate,title="D"	Button FS_FSmap_duplicate,fSize=9,valueColor=(0,0,65535)	//cuts tab中のmenu	SetVariable FS_cuts_Ek,pos={8,29},size={79,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="Ek"	SetVariable FS_cuts_Ek,limits={-inf,inf,0.001},value= cuts_coef[0]	SetVariable FS_cuts_a,pos={86,29},size={56,15},disable=1,proc=SetVarProc_FS_cuts_ab,title="a"	SetVariable FS_cuts_a,limits={-inf,inf,0.01},value= cuts_coef[1]	SetVariable FS_cuts_b,pos={141,29},size={56,15},disable=1,proc=SetVarProc_FS_cuts_ab,title="b"	SetVariable FS_cuts_b,limits={-inf,inf,0.01},value= cuts_coef[2]	SetVariable FS_cuts_acceptanceangle,pos={196,29},size={110,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="ang.accept."	SetVariable FS_cuts_acceptanceangle,limits={-inf,inf,0.01},value= cuts_coef[3]	Button FS_cuts_ReadPara,pos={308,27},size={52,20},disable=1,proc=ButtonProc_FS_cuts_reqadpara,title="ReadPara."	Button FS_cuts_ReadPara,fSize=9	Button FS_cuts_editpara,pos={365,29},size={15,16},disable=1,proc=ButtonProc_FS_cuts_editpara,title="P"	Button FS_cuts_editpara,fSize=9	SetVariable FS_cuts_theta,pos={8,49},size={82,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="theta"	SetVariable FS_cuts_theta,value= cuts_coef[4]	SetVariable FS_cuts_thetaoffset,pos={89,49},size={55,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title=" "	SetVariable FS_cuts_thetaoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_cuts_thetaoffset,limits={-inf,inf,0.1},value= cuts_coef[5]	SetVariable FS_cuts_tilt,pos={143,49},size={71,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="tilt"	SetVariable FS_cuts_tilt,value= cuts_coef[6]	SetVariable FS_cuts_tiltoffset,pos={213,49},size={54,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title=" "	SetVariable FS_cuts_tiltoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_cuts_tiltoffset,limits={-inf,inf,0.1},value= cuts_coef[7]	SetVariable FS_cuts_azimuth,pos={266,49},size={72,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="az."	SetVariable FS_cuts_azimuth,value= cuts_coef[8]	SetVariable FS_cuts_azimuthoffset,pos={337,49},size={54,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title=" "	SetVariable FS_cuts_azimuthoffset,valueBackColor=(65535,49151,49151)	SetVariable FS_cuts_azimuthoffset,limits={-inf,inf,0.1},value= cuts_coef[9]	SetVariable FS_cuts_start,pos={8,69},size={79,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="start"	SetVariable FS_cuts_start,fColor=(65535,0,0)	SetVariable FS_cuts_start,limits={-inf,inf,0.1},value= cuts_coef[10]	SetVariable FS_cuts_step,pos={86,69},size={48,15},disable=1,proc=SetVarProc_FS_cuts_Ek,title="step"	SetVariable FS_cuts_step,fColor=(65535,0,0)	SetVariable FS_cuts_step,limits={-inf,inf,0},value= cuts_coef[11]	SetVariable FS_cuts_cutnum,pos={137,69},size={46,15},disable=1,proc=SetVarProc_FS_cuts_cutnum,title="num"	SetVariable FS_cuts_cutnum,fColor=(65535,0,0)	SetVariable FS_cuts_cutnum,limits={-inf,inf,0},value= cuts_coef[12]	Button FS_cuts_append,pos={185,69},size={15,16},disable=1,proc=ButtonProc_FS_cuts_append,title="a"	Button FS_cuts_append,fSize=9,valueColor=(65535,0,0)	Button FS_cuts_remove,pos={201,69},size={15,16},disable=1,proc=ButtonProc_FS_cuts_remove,title="r"	Button FS_cuts_remove,fSize=9,valueColor=(65535,0,0)	PopupMenu FS_cuts_mode,pos={219,68},size={45,17},disable=1,proc=PopMenuProc_FS_cuts_mode	PopupMenu FS_cuts_mode,fSize=9	PopupMenu FS_cuts_mode,mode=1,popvalue="Theta",value= #"\"Theta;Tilt;Azimuth\""	SetVariable FS_cuts_FSangle,pos={300,69},size={70,15},disable=1,title="FSang"	SetVariable FS_cuts_FSangle,fColor=(0,0,65535)	SetVariable FS_cuts_FSangle,limits={-inf,inf,0},value= cuts_coef[14],live= 1	Button FS_cuts_calcFSangle,pos={373,69},size={15,16},disable=1,proc=ButtonProc_FS_cuts_calcFSangle,title="c"	Button FS_cuts_calcFSangle,fSize=9,valueColor=(0,0,65535)EndMacro